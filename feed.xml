<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://dpdms529.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://dpdms529.github.io/" rel="alternate" type="text/html" /><updated>2023-09-06T00:04:35+09:00</updated><id>https://dpdms529.github.io/feed.xml</id><title type="html">Joy’s Blog</title><subtitle>Joy의 블로그</subtitle><author><name>Joy</name></author><entry><title type="html">[스프링 핵심 원리 기본편] 9. 빈 스코프</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/9-%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 9. 빈 스코프" /><published>2023-06-02T02:15:00+09:00</published><updated>2023-06-02T02:15:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/9-%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/9-%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="빈-스코프란">빈 스코프란?</h2>
<ul>
  <li>스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어 스프링 컨테이너가 종료될 때까지 유지되는 이유는 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문</li>
  <li>스프링이 지원하는 스코프
    <ul>
      <li>싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 넓은 범위의 스코프</li>
      <li>프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프</li>
      <li>웹 관련 스코프
        <ul>
          <li>request : 웹 요청이 들어오고 나갈 때 까지 유지되는 스코프</li>
          <li>session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프</li>
          <li>application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="컴포넌트-스캔-자동-등록">컴포넌트 스캔 자동 등록</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloBean</span> <span class="o">{}</span>
</code></pre></div></div>

<h3 id="수동-등록">수동 등록</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
<span class="nd">@Bean</span>
<span class="nc">PrototypeBean</span> <span class="nf">HelloBean</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">HelloBean</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="싱글톤-스코프">싱글톤 스코프</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/55fd511a45e7ec2c27cebe7ff30398a131a9034d">https://github.com/dpdms529/SpringCore/commit/55fd511a45e7ec2c27cebe7ff30398a131a9034d</a></p>

<ul>
  <li>싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈 반환</li>
</ul>

<h3 id="싱글톤-빈-요청">싱글톤 빈 요청</h3>
<ol>
  <li>싱글톤 스코프의 빈을 스프링 컨테이너에 요청</li>
  <li>스프링 컨테이너는 본인이 관리하는 스프링 빈 반환</li>
  <li>이후에 스프링 컨테이너에 같은 요청이 오면 같은 객체 인스턴스의 스프링 빈 반환</li>
</ol>

<h2 id="프로토타입-스코프">프로토타입 스코프</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/c2b61b25bb7fdaedb069e58b2a4f63f621d43ee0">https://github.com/dpdms529/SpringCore/commit/c2b61b25bb7fdaedb069e58b2a4f63f621d43ee0</a></p>

<ul>
  <li>프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환</li>
</ul>

<h3 id="프로토타입-빈-요청">프로토타입 빈 요청</h3>
<ol>
  <li>프로토타입 스코프의 빈을 스프링 컨테이너에 요청</li>
  <li>스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계 주입</li>
  <li>스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환</li>
  <li>이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환</li>
</ol>

<h3 id="프로토타입-빈-특징">프로토타입 빈 특징</h3>
<ul>
  <li>스프링 컨테이너에 요청할 때마다 새로 생성</li>
  <li>스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입, 초기화까지만 관여</li>
  <li>종료 메서드가 호출되지 않음</li>
  <li>프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 함</li>
</ul>

<h3 id="싱글톤-빈에서-프로토타입-빈-사용시-문제점">싱글톤 빈에서 프로토타입 빈 사용시 문제점</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/3d3b0d6bf6e294052abb2065aad06c822bd84b7d">https://github.com/dpdms529/SpringCore/commit/3d3b0d6bf6e294052abb2065aad06c822bd84b7d</a></p>

<ul>
  <li>스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 됨</li>
  <li>싱글톤 빈은 생성 시점에만 의존관계를 주입 받기 때문에 프로토타입 빈이 새로 생성되기는 하지만 싱글톤 빈과 함께 계속 유지됨</li>
  <li>프로토타입 빈을 사용할 때마다 새로 생성하는 방식으로 사용할 수 없음</li>
</ul>

<h3 id="싱글톤-빈과-함께-사용시-provider로-문제-해결">싱글톤 빈과 함께 사용시 Provider로 문제 해결</h3>
<ul>
  <li>위의 문제를 해결하는 가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청하는 것</li>
  <li>의존관계를 외부에서 주입받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL, 의존관계 조회)라고 함</li>
  <li>이렇게 스프링 애플리케이션 컨테스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워짐</li>
</ul>

<h4 id="objectfactory-objectprovider">ObjectFactory, ObjectProvider</h4>
<p><a href="https://github.com/dpdms529/SpringCore/commit/b768421d57911c040c8ff984a7004b7657dc030e">https://github.com/dpdms529/SpringCore/commit/b768421d57911c040c8ff984a7004b7657dc030e</a></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider</code>가 지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공해줌</li>
  <li>과거에는 <code class="language-plaintext highlighter-rouge">ObjectFactory</code>를 사용했는데, 여기에 옵션, 스트림 처리 등 편의 기능을 추가해서 <code class="language-plaintext highlighter-rouge">ObjectProvider</code>가 만들어짐</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider</code>의 <code class="language-plaintext highlighter-rouge">getObject()</code>를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아 반환함</li>
  <li>기능이 단순하여 단위테스트를 만들거나 mock 코드를 만들기 쉬워짐</li>
  <li>별도의 라이브러리 필요 없음</li>
  <li>스프링에 의존함</li>
</ul>

<h4 id="jsr-330-provider">JSR-330 Provider</h4>
<p><a href="https://github.com/dpdms529/SpringCore/commit/187987fe3b7c3bcea6aeac0a479ab7df6d7acb1d">https://github.com/dpdms529/SpringCore/commit/187987fe3b7c3bcea6aeac0a479ab7df6d7acb1d</a></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">jakarta.inject.Provider</code>라는 JSR-330 자바 표준을 사용하는 방법</li>
  <li><code class="language-plaintext highlighter-rouge">jakarta.inject:jakarta.inject-api:2.0.1</code> 라이브러리를 gradle에 추가해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">Provider.get()</code>을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환함</li>
  <li>자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기 훨신 쉬움</li>
  <li><code class="language-plaintext highlighter-rouge">Provider</code>는 딱 필요한 DL정도의 기능만 제공함</li>
  <li>자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용 가능</li>
</ul>

<h2 id="웹-스코프">웹 스코프</h2>
<ul>
  <li>웹스코프는 웹 환경에서만 동작</li>
  <li>프로토타입과 다르게 스프링이 해당 슼코프의 종료시점까지 관리</li>
  <li>종료 메서드가 호출됨</li>
</ul>

<h3 id="웹-스코프-종류">웹 스코프 종류</h3>
<ul>
  <li>request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리됨</li>
  <li>session : Http Session과 동일한 생명주기를 가지는 스코프</li>
  <li>application : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프</li>
  <li>websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프</li>
</ul>

<h3 id="웹-환경-추가">웹 환경 추가</h3>
<ul>
  <li>웹 스코프는 웹 환경에서만 동작하므로 <code class="language-plaintext highlighter-rouge">build.gradle</code>에 <code class="language-plaintext highlighter-rouge">implementation 'org.springframework.boot:spring-boot-starter-web</code>를 추가해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-starter-web</code> 라이브러리를 추가하면 스프링 부트는 내장 톰캣 서버를 활용해서 웹 서버와 스프링을 함께 실행시킴</li>
  <li>웹 라이브러리가 추가되면 <code class="language-plaintext highlighter-rouge">AnnotationConfigServletWebServerApplicationContext</code>를 기반으로 애플리케이션을 구동</li>
</ul>

<h3 id="request-스코프-예제">request 스코프 예제</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/d731c34fb914778af30b44b4874b123d32f8d53d">https://github.com/dpdms529/SpringCore/commit/d731c34fb914778af30b44b4874b123d32f8d53d</a></p>
<ul>
  <li>오류 발생함</li>
  <li>스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 실제 고객의 요청이 와야 생성할 수 있음</li>
</ul>

<h3 id="스코프와-provider">스코프와 Provider</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/fef6930d5d88a2fbf28f0d4d169fcbc4d3eda3a3">https://github.com/dpdms529/SpringCore/commit/fef6930d5d88a2fbf28f0d4d169fcbc4d3eda3a3</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider</code>로 <code class="language-plaintext highlighter-rouge">ObjectProvider.getObject()</code>를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider.getObject()</code>를 <code class="language-plaintext highlighter-rouge">LogDemoController</code>, <code class="language-plaintext highlighter-rouge">LogDemoService</code>에서 각각 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환됨</li>
</ul>

<h3 id="스코프와-프록시">스코프와 프록시</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/4029ae38f596e726e55b311f612721cacf528686">https://github.com/dpdms529/SpringCore/commit/4029ae38f596e726e55b311f612721cacf528686</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Scope</code>에 <code class="language-plaintext highlighter-rouge">proxyMode = ScopedProxyMode.TARGET_CLASS</code> 추가
    <ul>
      <li>적용 대상이 인터페이스가 아닌 클래스면 <code class="language-plaintext highlighter-rouge">TARGET_CLASS</code></li>
      <li>적용 대상이 인터페이스면 <code class="language-plaintext highlighter-rouge">INTERFACES</code></li>
    </ul>
  </li>
  <li>가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해둘 수 있음</li>
  <li>CGLIB라는 라이브러리로 클래스를 상속받은 가짜 프록시 객체를 만들어서 주입</li>
  <li>가짜 프록시 객체는 요청이 오면 그 때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있음</li>
  <li>진짜 객체 조회를 필요한 시점까지 지연처리</li>
</ul>

<h4 id="주의점">주의점</h4>
<ul>
  <li>마치 싱글톤을 사용하는 것 같지만 다르게 동작하므로 주의해서 사용해야 함</li>
  <li>무분별하게 사용하면 유지보수가 어려우므로 특별한 scope는 필요한 곳에만 최소화해서 사용해야함</li>
</ul>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 8. 빈 생명주기 콜백</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/8-%EB%B9%88-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EC%BD%9C%EB%B0%B1/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 8. 빈 생명주기 콜백" /><published>2023-05-31T11:26:00+09:00</published><updated>2023-05-31T11:26:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/8-%EB%B9%88-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EC%BD%9C%EB%B0%B1</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/8-%EB%B9%88-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EC%BD%9C%EB%B0%B1/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="빈-생명주기-콜백-시작">빈 생명주기 콜백 시작</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/0f3d1de78f5b14aa2293c79d5f7e735dc264054e">https://github.com/dpdms529/SpringCore/commit/0f3d1de78f5b14aa2293c79d5f7e735dc264054e</a></p>

<ul>
  <li>데이터베이스 커넥션 풀이나, 네티워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요</li>
  <li>스프링 빈은 객체를 생성하고 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료됨</li>
  <li>따라서 초기화 작업은 의존관계 주입이 모두 완료된 후에 호출해야 함</li>
  <li>스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공</li>
  <li>스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 줌</li>
</ul>

<h3 id="스프링-빈의-이벤트-라이프사이클">스프링 빈의 이벤트 라이프사이클</h3>
<ol>
  <li>스프링 컨테이너 생성</li>
  <li>스프링 빈 생성</li>
  <li>의존관계 주입</li>
  <li>초기화 콜백
    <ul>
      <li>빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출</li>
    </ul>
  </li>
  <li>사용</li>
  <li>소멸전 콜백
    <ul>
      <li>빈이 소멸되기 직전에 호출</li>
    </ul>
  </li>
  <li>스프링 종료</li>
</ol>

<h3 id="객체의-생성과-초기화를-분리하자">객체의 생성과 초기화를 분리하자</h3>
<ul>
  <li>생성자는 필수 정보를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가짐</li>
  <li>초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행</li>
  <li>생성자 안에서 무거운 초기화 작업을 함께 하는 것보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋음</li>
  <li>초기화 작업이 단순한 경우에는 생성자에서 한번에 다 처리하는게 나을 수 있음</li>
</ul>

<h2 id="스프링-빈-생명주기-콜백-방식">스프링 빈 생명주기 콜백 방식</h2>

<h3 id="인터페이스-initializingbean-disposablebean">인터페이스 InitializingBean, DisposableBean</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/08b458638ca7054649bb4f890df9473a8dfdf997">https://github.com/dpdms529/SpringCore/commit/08b458638ca7054649bb4f890df9473a8dfdf997</a></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">InitializingBean</code> : <code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code> 메서드로 초기화를 지원</li>
  <li><code class="language-plaintext highlighter-rouge">DisposableBean</code> : <code class="language-plaintext highlighter-rouge">destroy()</code> 메소드로 소멸을 지원</li>
</ul>

<h4 id="초기화-소멸-인터페이스-단점">초기화, 소멸 인터페이스 단점</h4>
<ul>
  <li>스프링 전용 인터페이스에 의존</li>
  <li>초기화, 소멸 메서드의 이름 변경 불가능</li>
  <li>내가 코드를 고칠 수 없는 외부 라이브러리에 적용 불가능</li>
  <li>지금은 거의 사용하지 않음</li>
</ul>

<h3 id="빈-등록-초기화-소멸-메서드-지정">빈 등록 초기화, 소멸 메서드 지정</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/4c4dbe76f5c28249fc0be38cfc138a2775181c24">https://github.com/dpdms529/SpringCore/commit/4c4dbe76f5c28249fc0be38cfc138a2775181c24</a></p>

<ul>
  <li>설정 정보에 <code class="language-plaintext highlighter-rouge">@Bean(initMethod = "init</code>, destroyMethod = “close”)처럼 초기화, 소멸 메서드를 지정 가능</li>
  <li>메서드 이름을 자유롭게 줄 수 있음</li>
  <li>스프링 빈이 스프링 코드에 의존하지 않음</li>
  <li>코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용 가능</li>
</ul>

<h4 id="종료-메서드-추론">종료 메서드 추론</h4>
<ul>
  <li>라이브러리 대부분은 종료 메서드 이름으로 <code class="language-plaintext highlighter-rouge">close</code>, <code class="language-plaintext highlighter-rouge">shutdown</code> 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@Bean</code>의 <code class="language-plaintext highlighter-rouge">destroyMethod</code>는 기본값이 <code class="language-plaintext highlighter-rouge">(inferred)</code>로 등록되어 있음</li>
  <li>이 추론 기능은 <code class="language-plaintext highlighter-rouge">close</code>, <code class="language-plaintext highlighter-rouge">shutdown</code>이라는 이름의 메소드를 자동으로 호출해줌</li>
  <li>직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 작 동작함</li>
  <li>추론 기능을 사용하기 싫으면 <code class="language-plaintext highlighter-rouge">destroyMethod= ""</code> 처럼 빈 공백을 지정하면 됨</li>
</ul>

<h3 id="애노테이션-postconstruct-predestroy">애노테이션 @PostConstruct, @PreDestroy</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/1ceedf77aa8bb71bd195bdbc177392295bc0bf40">https://github.com/dpdms529/SpringCore/commit/1ceedf77aa8bb71bd195bdbc177392295bc0bf40</a></p>

<ul>
  <li>최신 스프링에서 가장 권장하는 방법</li>
  <li>애노테이션 하나만 붙이면 되서 매우 편리</li>
  <li>스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 동작함</li>
  <li>컴포넌트 스캔과 잘 어울림</li>
  <li>유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것</li>
  <li>외부 라이브러리를 초기화, 종료 해야 하면 <code class="language-plaintext highlighter-rouge">@Bean</code> 기능을 사용</li>
</ul>

<h2 id="정리">정리</h2>
<ul>
  <li>@PostConstruct, @PreDestory 애노테이션을 사용하자</li>
  <li>코드를 고칠 수 없는 이부 라이브러리를 초기화, 종료해야 하면 <code class="language-plaintext highlighter-rouge">@Bean</code>의 <code class="language-plaintext highlighter-rouge">initMethod</code>, <code class="language-plaintext highlighter-rouge">destroyMethod</code>를 사용하자</li>
</ul>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[Jekyll 블로그] Github Actions로 배포</title><link href="https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Github-Actions%EB%A1%9C-%EB%B0%B0%ED%8F%AC/" rel="alternate" type="text/html" title="[Jekyll 블로그] Github Actions로 배포" /><published>2023-05-23T21:50:00+09:00</published><updated>2023-05-23T21:50:00+09:00</updated><id>https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Github-Actions%EB%A1%9C-%EB%B0%B0%ED%8F%AC</id><content type="html" xml:base="https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Github-Actions%EB%A1%9C-%EB%B0%B0%ED%8F%AC/"><![CDATA[<h2 id="github-actions">Github Actions</h2>
<p><a href="https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%83%9D%EC%84%B1/#github-pages%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9D%B4%EC%9C%A0">이전 포스트</a>에서 설명했다시피 블로그의 변경사항을 자동 배포하기 위해 <a href="https://github.com/features/actions">Github Actions</a>를 사용해보려한다.</p>

<ol>
  <li>
    <p>Actions 탭에 들어가서 <code class="language-plaintext highlighter-rouge">set up a workflow youself</code>를 클릭한다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/eaeba9d4-6f1b-4b83-bfb1-17c60387e45d" alt="Github Actions" /></p>
  </li>
  <li>
    <p>파일명을 <code class="language-plaintext highlighter-rouge">github-pages</code>로 하고 내용을 다음과 같이 작성한다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/c9321d3d-571f-4c93-be9f-dd7467c4752f" alt="github-pages.yml" /></p>

    <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">name</span><span class="pi">:</span> <span class="s">Build and deploy Jekyll site to GitHub Pages</span>

 <span class="na">on</span><span class="pi">:</span>
 <span class="na">push</span><span class="pi">:</span>
     <span class="na">branches</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">main</span>

 <span class="na">jobs</span><span class="pi">:</span>
 <span class="na">github-pages</span><span class="pi">:</span>
     <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
     <span class="na">steps</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
     <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/cache@v2</span>
         <span class="s">with</span><span class="err">:</span>
         <span class="na">path</span><span class="pi">:</span> <span class="s">vendor/bundle</span>
         <span class="na">key</span><span class="pi">:</span> <span class="s">$-gems-$</span>
         <span class="na">restore-keys</span><span class="pi">:</span> <span class="pi">|</span>
             <span class="s">$-gems-</span>
     <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">helaili/jekyll-action@2.5.0</span>
         <span class="s">with</span><span class="err">:</span>                                
         <span class="na">token</span><span class="pi">:</span> <span class="s">$</span>
         <span class="na">target_branch</span><span class="pi">:</span> <span class="s1">'</span><span class="s">gh-pages'</span>
         <span class="na">pre_build_commands</span><span class="pi">:</span> <span class="s1">'</span><span class="s">gem</span><span class="nv"> </span><span class="s">update</span><span class="nv"> </span><span class="s">--system'</span>
</code></pre></div>    </div>

    <p>위와 같이 설정하면 <code class="language-plaintext highlighter-rouge">main</code>브랜치에 변경 사항이 생겼을 때마다 <code class="language-plaintext highlighter-rouge">main</code> 브랜치의 내용으로 정적인 페이지들을 만들어서 <code class="language-plaintext highlighter-rouge">gh-pages</code> 브랜치에 올려준다.</p>
  </li>
  <li>
    <p><a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a> 에서 <code class="language-plaintext highlighter-rouge">Generate new token</code>을 한 후 Note에는 <code class="language-plaintext highlighter-rouge">JEKYLL_TOKEN</code>를 입력하고, Expiration은 <code class="language-plaintext highlighter-rouge">No expiration</code>, Select scopes는 <code class="language-plaintext highlighter-rouge">public_repo</code>를 선택해준다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/efe70843-59d3-4531-b63d-23caf3a1dcf3" alt="token 설정" /></p>
  </li>
  <li>
    <p>생성된 token 값을 복사해준다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/0b999a41-edfd-434b-870e-7bb0a0653102" alt="token 생성" /></p>
  </li>
  <li>
    <p>레포지토리로 돌아와서 <code class="language-plaintext highlighter-rouge">Setting</code>의 <code class="language-plaintext highlighter-rouge">Secrets and variables</code>에 들어가서 <code class="language-plaintext highlighter-rouge">New repository secret</code>으로 위에서 만들었던 <code class="language-plaintext highlighter-rouge">JEKYLL_TOKEN</code>을 secret으로 등록해준다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/7224431f-819e-4a89-877d-d9b3b8957afe" alt="secret 등록" /></p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/476313b7-fc42-4e8d-b1c3-7c6443b80e98" alt="secret 설정" /></p>
  </li>
  <li>
    <p>지금까지의 변경사항을 모두 <code class="language-plaintext highlighter-rouge">commit</code> 후 <code class="language-plaintext highlighter-rouge">push</code> 해주면 <code class="language-plaintext highlighter-rouge">Actions</code>의 <code class="language-plaintext highlighter-rouge">workflow</code>에 commit한 내용이 올라가고 <code class="language-plaintext highlighter-rouge">gh-pages</code>라는 브랜치가 생성된다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/20fdb4b6-23d8-4b6f-babc-86406ea31cde" alt="workflow" /></p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/64d6b8f4-de76-48ce-a8e9-b0f569224e73" alt="gh-pages" /></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Settings</code>의 <code class="language-plaintext highlighter-rouge">Pages</code>에 들어가서 배포할 브랜치를 <code class="language-plaintext highlighter-rouge">gh-pages</code>를 변경해준다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/05b14c12-219e-48ed-a522-d60271d18f1d" alt="Pages 설정" /></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">https://&lt;사용자이름&gt;.github.io/</code>로 접속하면 Github Pages로 블로그가 호스팅되고 있는 것을 확인할 수 있다.</p>
  </li>
</ol>]]></content><author><name>Joy</name></author><category term="Experiences" /><category term="Jekyll 블로그" /><category term="Experiences" /><category term="Jekyll 블로그" /></entry><entry><title type="html">[Jekyll 블로그] Jekyll 블로그 생성</title><link href="https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%83%9D%EC%84%B1/" rel="alternate" type="text/html" title="[Jekyll 블로그] Jekyll 블로그 생성" /><published>2023-05-23T16:53:00+09:00</published><updated>2023-05-23T16:53:00+09:00</updated><id>https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%83%9D%EC%84%B1</id><content type="html" xml:base="https://dpdms529.github.io/experiences/jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8/Jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%83%9D%EC%84%B1/"><![CDATA[<h2 id="jekyll-블로그-시작">Jekyll 블로그 시작!</h2>
<p>블로그를 한동안 방치했었는데 시간도 생겼고, 다시 잘 운영해보고 싶어서 싹 밀고 새로 만들었다. 한 번 했었으니깐 다시 만들면 금방 만들 줄 았았는데 생각보다 시간이 오래 걸렸다. 혹시 또 jekyll 블로그를 새로 만들고 싶어질지도 모르니깐 블로그 생성 과정을 정리해보려고 한다.</p>

<h2 id="설치">설치</h2>
<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://jekyllrb.com/docs/installation/windows/" target="_blank">
          <img src="https://jekyllrb.com/img/jekyll-og.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://jekyllrb.com/docs/installation/windows/" target="_blank">Jekyll on Windows</a>
        </h2>
        <div class="jekyll-linkpreview-description">While Windows is not an officially-supported platform, it can be used to run Jekyll with the proper tweaks.</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//jekyllrb.com" target="_blank">jekyllrb.com</a>
    </div>
  </div>
</div>

<p>jekyll을 사용하기 위해서는 먼저 ruby를 설치해야 한다. 나는 Window를 쓰고 있기 때문에 <a href="https://rubyinstaller.org/">RubyInstaller</a>를 통해 ruby를 설치해줬다.</p>

<p>설치 마지막 단계에서 <code class="language-plaintext highlighter-rouge">ridk install</code>을 체크해준 후 finish 버튼을 누르면 아래와 같은 화면이 띄어진다.</p>

<p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/d8f549db-f437-41a1-8b63-0f2d28674836" alt="Ruby ridk install" /></p>

<p>문서 내용으로는 3번만 설치해주면되는거 같지만 나는 그냥 Enter를 눌러서 다 설치해줬다.</p>

<p>ruby 설치가 모두 끝나면 cmd 창에서 <code class="language-plaintext highlighter-rouge">gem install jekyll bundler</code>을 통해 jekyll과 bundler를 설치해준다. 설치가 끝나면 <code class="language-plaintext highlighter-rouge">jekyll -v</code>을 통해 jekyll이 제대로 설치됐는지 확인해준다.</p>

<h2 id="minimal-mistakes">Minimal Mistakes</h2>
<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/" target="_blank">
          <img src="https://mmistakes.github.io/minimal-mistakes/assets/images/site-logo.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/" target="_blank">Quick-Start Guide</a>
        </h2>
        <div class="jekyll-linkpreview-description">How to quickly install and setup Minimal Mistakes for use with GitHub Pages.</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//mmistakes.github.io" target="_blank">mmistakes.github.io</a>
    </div>
  </div>
</div>

<p>jekyll theme에는 여러가지가 있는데 나는 Minimal Mistakes를 골랐다. 원래도 이 테마를 썼었는데 가이드 문서가 잘 되어있고, 많은 사람들이 사용하다보니 참고할 글도 많아서 커스터마이징할 때 생기는 문제들을 해결할 때 도움이 많이 됐었어서 그대로 쓰기로 했다.</p>

<p>테마를 설치하는 방법은 여러가지가 있는데 나는 Github repository에서 clone해오는 방법을 선택했다.</p>
<ol>
  <li>
    <p>github repository 만들기<br />
 Repository name은 <code class="language-plaintext highlighter-rouge">사용자이름.github.io</code>로 설정해준다.</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/6c0122ca-13d5-4eeb-ad93-4a1b8002b858" alt="repository 생성" /></p>
  </li>
  <li>
    <p>자신의 블로그 레포지토리 주소를 복사해와서 clone 해준 후 해당 폴더로 이동</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/12e045f1-d93b-4491-923e-4c49a015842b" alt="repository clone" /></p>

    <p><code class="language-plaintext highlighter-rouge">cd &lt;폴더를 만들 위치&gt;</code></p>

    <p><code class="language-plaintext highlighter-rouge">git clone &lt;블로그 레포지토리 주소&gt; 폴더명</code></p>

    <p><code class="language-plaintext highlighter-rouge">cd &lt;폴더명&gt;</code></p>
  </li>
  <li>
    <p><a href="https://github.com/mmistakes/minimal-mistakes">minimal-mistakes</a>를 remote repository로 추가해준 후 pull해오기</p>

    <p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/ef104b34-39ef-40d1-b643-76aa11f37899" alt="minimal mistakes pull" /></p>

    <p><code class="language-plaintext highlighter-rouge">git remote add minimal https://github.com/mmistakes/minimal-mistakes.git</code></p>

    <p><code class="language-plaintext highlighter-rouge">git remote -v</code></p>

    <p><code class="language-plaintext highlighter-rouge">git pull minimal master</code></p>
  </li>
</ol>

<h2 id="필요-없는-폴더-및-파일-삭제">필요 없는 폴더 및 파일 삭제</h2>
<p>minimal-mistakes의 master 브랜치를 pull 해오면 다음과 같은 디렉터리 구조를 가지는데 빨간 박스 표시를 한 폴더 및 파일들은 예시를 위한 것들이기 때문에 지워주면된다.</p>

<p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/013e51b2-d74d-402f-9606-f3c7bb5b58b3" alt="디렉터리 구조" width="400" height="400" /></p>

<h2 id="gemfile-수정">Gemfile 수정</h2>
<p>Gemfile을 다음과 같이 수정해준다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">source</span> <span class="s2">"https://rubygems.org"</span>

<span class="n">gem</span> <span class="s1">'jekyll'</span><span class="p">,</span> <span class="s1">'~&gt; 4.2'</span>
<span class="n">gem</span> <span class="s2">"minimal-mistakes-jekyll"</span>

<span class="n">platforms</span> <span class="ss">:mingw</span><span class="p">,</span> <span class="ss">:x64_mingw</span><span class="p">,</span> <span class="ss">:mswin</span><span class="p">,</span> <span class="ss">:jruby</span> <span class="k">do</span>
    <span class="n">gem</span> <span class="s2">"tzinfo"</span><span class="p">,</span> <span class="s2">"&gt;= 1"</span><span class="p">,</span> <span class="s2">"&lt; 3"</span>
    <span class="n">gem</span> <span class="s2">"tzinfo-data"</span>
<span class="k">end</span>

<span class="n">gem</span> <span class="s1">'wdm'</span><span class="p">,</span> <span class="s1">'~&gt; 0.1.1'</span><span class="p">,</span> <span class="ss">:install_if</span> <span class="o">=&gt;</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">win_platform?</span>
</code></pre></div></div>

<h3 id="github-pages를-사용하지-않은-이유">github-pages를 사용하지 않은 이유</h3>
<p><code class="language-plaintext highlighter-rouge">jekyll</code> 대신 <code class="language-plaintext highlighter-rouge">github-pages</code>를 설치할 수도 있는데, github-pages를 사용하면 따로 설정하지 않아도 push한 내용들을 <code class="language-plaintext highlighter-rouge">Github Pages</code>에 자동으로 배포해주지만 jekyll의 최신 버전을 사용할 수 없다. 처음에는 최신 버전을 굳이 사용할 필요를 못느껴서 github-pages를 사용했었는데 url 설정 문제 때문에 최신 버전을 사용해야 할 필요성을 느끼게되었다.</p>

<p><code class="language-plaintext highlighter-rouge">_config.yml</code>에서 <code class="language-plaintext highlighter-rouge">Outputting</code> 부분을 보면 post의 url을 <code class="language-plaintext highlighter-rouge">permalink: /:categories/:title/</code> 과 같이 설정해놓은 것을 볼 수 있다. 이렇게 되면 포스트의 url 주소가 <code class="language-plaintext highlighter-rouge">/&lt;카테고리명&gt;/&lt;포스트제목&gt;/</code> 으로 설정된다. 그런데 이 설정의 경우 포스트 제목에는 <code class="language-plaintext highlighter-rouge">slugify</code>가 적용되는데 카테고리명에는 <code class="language-plaintext highlighter-rouge">slugify</code>가 적용되지 않는다. <code class="language-plaintext highlighter-rouge">slugify</code>는 url을 url 친화적이도록 대문자는 소문자로, 띄어쓰기나 기호는 - 로 바꿔주는 역할을 한다.</p>

<p><code class="language-plaintext highlighter-rouge">slugify</code>가 적용되지 않을 경우, 카테고리명이 <code class="language-plaintext highlighter-rouge">Hello World</code>라면 url이 <code class="language-plaintext highlighter-rouge">/Hello%20World/...</code>으로 설정되는데 보기에도 좋지않고, 나중에 카테고리 페이지를 만들었을 때 그 페이지는 url이 <code class="language-plaintext highlighter-rouge">/hello-world/...</code>로 설정되기 때문에 매칭이 안되는 문제가 있다.</p>

<p>그래서 이것을 해결할 방법을 찾아보던 중 <a href="https://jekyllrb.com/docs/permalinks/">공식 문서</a>에서 <code class="language-plaintext highlighter-rouge">_config.yml</code>의 post url 설정 부분에서 <code class="language-plaintext highlighter-rouge">:categories</code> 대신 <code class="language-plaintext highlighter-rouge">:slugified_categories</code>를 사용하면 된다는 내용을 찾았다.</p>

<p>그런데 이 기능은 jekyll 4.1버전부터 가능해서 github-pages에 의존된 jekyll 버전(v3.9.3)으로는 사용할 수가 없었다.</p>

<p>그래서 github-pages 대신 jekyll의 최신 버전을 사용하고, <code class="language-plaintext highlighter-rouge">Github Actions</code>를 사용하여 Github Pages에 블로그의 변경사항을 자동 배포하는 방법을 찾게되었다. 그 내용은 다음 포스팅에 쓰도록 하겠다.</p>

<h2 id="로컬에서-실행하기">로컬에서 실행하기</h2>
<p>터미널을 열어서 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code>를 실행시킨 후 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a>에 들어가보면 다음과 같이 minimal mistakes 테마가 적용된 jekyll 블로그가 만들어진 것을 볼 수 있다.</p>

<p><img src="https://github.com/dpdms529/dpdms529.github.io/assets/60471550/237c1862-f882-4a67-a7a4-f6e3bb32f6b1" alt="jekyll 블로그" /></p>]]></content><author><name>Joy</name></author><category term="Experiences" /><category term="Jekyll 블로그" /><category term="Experiences" /><category term="Jekyll 블로그" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 7. 의존관계 자동 주입</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/7-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 7. 의존관계 자동 주입" /><published>2023-05-17T16:08:00+09:00</published><updated>2023-05-17T16:08:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/7-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/7-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="다양한-의존관계-주입-방법">다양한 의존관계 주입 방법</h2>

<h3 id="생성자-주입">생성자 주입</h3>
<ul>
  <li>생성자를 통해 의존 관계를 주입 받는 방법</li>
  <li>생성자 호출 시점에 딱 1번만 호출되는 것이 보장</li>
  <li>불변, 필수 의존관계에 사용</li>
  <li>생성자가 1개만 있으면 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 생략해도 자동 주입됨</li>
</ul>

<h3 id="수정자-주입">수정자 주입</h3>
<ul>
  <li>setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법</li>
  <li>선택, 변경 가능성이 있는 의존관계에 사용</li>
  <li>자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법</li>
  <li><code class="language-plaintext highlighter-rouge">@Autowired</code>의 기본 동작은 주입할 대상이 없으면 오류 발생
    <ul>
      <li>주입할 대상이 없어도 동작하게 하려면 <code class="language-plaintext highlighter-rouge">@Autowired(required = false)</code></li>
    </ul>
  </li>
</ul>

<h3 id="필드-주입">필드 주입</h3>
<ul>
  <li>필드에 바로 주입하는 방법</li>
  <li>코드가 간결하지만 외부에서 변경이 불가능해서 테스트하기 힘들다는 단점 존재</li>
  <li>DI 프레임워크가 없으면 아무것도 할 수 없음</li>
  <li>사용하지 말자
    <ul>
      <li>애플리케이션의 실제 코드와 관계 없는 테스트 코드</li>
      <li>스프링 설정을 목적으로 하는 <code class="language-plaintext highlighter-rouge">@Configuration</code> 같은 곳에서만 특별한 용도로 사용</li>
    </ul>
  </li>
</ul>

<h3 id="일반-메서드-주입">일반 메서드 주입</h3>
<ul>
  <li>일반 메서드를 통해 주입받을 수 있음</li>
  <li>한번에 여러 필드를 주입받을 수 있음</li>
  <li>일반적으로 잘 사용하지 않음</li>
</ul>

<h2 id="옵션-처리">옵션 처리</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/e1511d9b8184e533a9439b402e1a6967a633fc81">코드</a></p>
<ul>
  <li>주입할 스프링 빈이 없어도 동작해야 할 때가 있음</li>
  <li><code class="language-plaintext highlighter-rouge">@Autowired</code>만 사용하면 <code class="language-plaintext highlighter-rouge">required</code> 옵션의 기본값이 <code class="language-plaintext highlighter-rouge">true</code>로 되어 있어 자동 주입 대상이 없으면 오류 발생</li>
  <li>자동 주입 대상을 옵션으로 처리하는 방법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Autowired(required=false)</code> : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨</li>
      <li><code class="language-plaintext highlighter-rouge">org.springframework.lang.@Nullable</code> : 자동 주입할 대상이 없으면 null이 입력됨</li>
      <li><code class="language-plaintext highlighter-rouge">Optional&lt;&gt;</code> : 자동 주입할 대상이 없으면 Optional.empty가 입력됨</li>
    </ul>
  </li>
</ul>

<h2 id="생성자-주입을-선택해라">생성자 주입을 선택해라!</h2>
<h3 id="불변">불변</h3>
<ul>
  <li>대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없음</li>
  <li>수정자 주입을 사용하면 set 메서드를 public으로 열어두어야 함</li>
  <li>누군가 실수로 변경할 수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아님</li>
  <li>생성자 주입은 객체를 생성할 대 딱 1번만 호출되므로 이후에는 호출되는 일이 없음 -&gt; 불변하게 설계 가능</li>
</ul>

<h3 id="누락">누락</h3>
<ul>
  <li>생성자 주입을 사용하면 의존관계 주입이 누락되었을 때 컴파일 오류가 발생</li>
  <li>IDE에서 바로 어떤 값을 필수로 주입해야 하는지 알 수 있음</li>
</ul>

<h3 id="final-키워드">final 키워드</h3>
<ul>
  <li>생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아줌</li>
  <li>나머지 주입 방식은 모두 생성자 이후에 호출되므로 생성자 주입 방식만 final 키워드 가능</li>
</ul>

<h2 id="롬북과-최신-트랜드">롬북과 최신 트랜드</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/2e9b42e508bc7b7b425ce0bf5a7286ca4f7134d3">코드</a></p>
<ul>
  <li>getter, setter, 생성자, toString 등을 자동으로 만들어줌</li>
  <li><code class="language-plaintext highlighter-rouge">@RequiredArgsConstructor</code> 를 사용하면 final이 붙은 필드를 모아서 생성자를 자동으로 만들어줌</li>
  <li>최근에는 생성자를 1개 두고 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 생략하고 Lombok 라이브러리의 <code class="language-plaintext highlighter-rouge">@RequiredArgsConstructor</code>를 사용하는 방법을 주로 사용</li>
</ul>

<h2 id="조회-빈이-2개-이상">조회 빈이 2개 이상</h2>
<h3 id="autowired-필드-명-매칭"><code class="language-plaintext highlighter-rouge">@Autowired</code> 필드 명 매칭</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/99fa3683a189bd3d3c7864eea8bec0e8eebdbdc3">코드</a></p>
<ol>
  <li>타입 매칭</li>
  <li>타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭</li>
</ol>

<h3 id="qualifier-사용"><code class="language-plaintext highlighter-rouge">@Qualifier</code> 사용</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/ac3d6258955a1f1f4fc9bcd5d489bfdeb0c9fbc1">코드</a></p>
<ul>
  <li>추가 구분자를 붙여주는 방법</li>
  <li>주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아님</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">@Qualifier</code> 끼리 매칭</li>
  <li>빈 이름 매칭</li>
  <li><code class="language-plaintext highlighter-rouge">NoSUchBeanDefinitionException</code> 발생</li>
</ol>

<h3 id="primary-사용"><code class="language-plaintext highlighter-rouge">@Primary</code> 사용</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/25a4a46b127952c1e7060d8d98a9cfeba6291176">코드</a></p>
<ul>
  <li>우선순위를 정하는 방법</li>
  <li><code class="language-plaintext highlighter-rouge">@Qualifier</code>가 <code class="language-plaintext highlighter-rouge">@Primary</code>보다 우선권이 높음</li>
</ul>

<h2 id="애노테이션-직접-만들기">애노테이션 직접 만들기</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/8b7653c9703fa1066e44cfd1e7987c8f0d8c77d1">코드</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Qualifier("mainDiscountPolicy")</code>와 같이 문자로 적으면 컴파일시 타입 체크가 안됨</li>
  <li>애노테이션을 만들어서 해결</li>
</ul>

<h2 id="조회한-빈이-모두-필요할-때-list-map">조회한 빈이 모두 필요할 때, List Map</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/4a8db025aeeccd0cc543e6777981e24685a3e06b">코드</a></p>

<h2 id="자동-수동의-올바른-실무-운영-기준">자동, 수동의 올바른 실무 운영 기준</h2>
<ul>
  <li>자동 기능을 기본으로 사용</li>
  <li>업무 로직 빈 : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등</li>
  <li>기술 지원 빈 : 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용, 데이터베이스 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술</li>
  <li>업무 로직 빈은 자동, 기술 지원 빈은 수동 빈 등록이 좋음</li>
  <li>다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민</li>
</ul>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 6. 컴포넌트 스캔</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%EC%BA%94/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 6. 컴포넌트 스캔" /><published>2023-05-11T23:18:00+09:00</published><updated>2023-05-11T23:18:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%EC%BA%94</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%EC%BA%94/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="컴포넌트-스캔과-의존관계-자동-주입">컴포넌트 스캔과 의존관계 자동 주입</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/82442acff38bb92e39c5bca55fa6eb3d0eeddb87">코드</a></p>
<ul>
  <li>스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능 제공</li>
  <li>의존관계를 자동으로 주입하는 <code class="language-plaintext highlighter-rouge">@Autowired</code> 기능 제공</li>
</ul>

<h3 id="동작-과정">동작 과정</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">@ComponentScan</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Component</code>가 붙은 모든 클래스를 스프링 빈으로 등록</li>
      <li>스프링 빈 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자 사용
        <ul>
          <li>ex) MemberServiceImpl 클래스 -&gt; memberServiceImpl</li>
          <li>빈 이름 직접 지정 : <code class="language-plaintext highlighter-rouge">@Component("beanName")</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Autowired</code> 의존관계 자동 주입
    <ul>
      <li>생성자에 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입</li>
      <li>기본 조회 전략은 타입이 같은 빈을 찾아서 주입</li>
      <li>생성자에 파라미터가 많아도 다 찾아서 자동으로 주입</li>
    </ul>
  </li>
</ol>

<h2 id="탐색-위치와-기본-스캔-대상">탐색 위치와 기본 스캔 대상</h2>
<h3 id="탐색할-패키지의-시작-위치-지정">탐색할 패키지의 시작 위치 지정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">basePackages</code> : 탐색할 패키지의 시작 위치를 지정
    <ul>
      <li>이 패키지를 포함해서 하위 패키지를 모두 탐색</li>
      <li>{}로 시작 위치를 여러개 지정 가능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">basePackageClasses</code> : 지정한 클래스의 패키지를 탐색 시작 위치로 지정</li>
  <li>지정하지 않으면 <code class="language-plaintext highlighter-rouge">@ComponentScan</code>이 붙은 설정 정보 클래스의 패키지가 시작 위치</li>
  <li>설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것을 권장</li>
  <li>스프링 부트를 사용하면 스프링 부트의 대표 시작 정보인 <code class="language-plaintext highlighter-rouge">@SpringBootApplication</code>을 프로젝트 시작 루트 위치에 두는 것이 관례
    <ul>
      <li>이 설정 안에 <code class="language-plaintext highlighter-rouge">@ComponentScan</code>이 들어있음</li>
    </ul>
  </li>
</ul>

<h3 id="컴포넌트-스캔-기본-대상">컴포넌트 스캔 기본 대상</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Component</code> : 컴포넌트 스캔에서 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@Controller</code> : 스프링 MVC 컨트롤러에서 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@Service</code> : 스프링 비즈니스 로직에서 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@Repository</code> : 스프링 데이터 접근 계층에서 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@Configuration</code> : 스프링 설정 정보에서 사용</li>
</ul>

<h2 id="필터">필터</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/87ea9018984c19b93a37aabe8453efaa267e5260">코드</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">includeFilters</code> : 컴포넌트 스캔 대상을 추가로 지정</li>
  <li><code class="language-plaintext highlighter-rouge">excludeFilters</code> : 컴포넌트 스캔에서 제외할 대상을 지정</li>
</ul>

<h3 id="filtertype-옵션">FilterType 옵션</h3>
<ul>
  <li>ANNOTATION : 기본값, 애노테이션을 인식해서 동작</li>
  <li>ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 인식해서 동작</li>
  <li>ASPECTJ : AspectJ 패턴 사용</li>
  <li>REGEX : 정규 표현식</li>
  <li>
    <p>CUSTOM : <code class="language-plaintext highlighter-rouge">TypeFilter</code>이라는 인터페이스를 구현해서 처리</p>
  </li>
  <li>스프링 부트는 컴포넌트 스캔을 기본으로 제공하고 있으며, 옵션을 변경하기 보다 스프링의 기본 설정에 맞춰 사용하는 것을 권장</li>
</ul>

<h2 id="중복-등록과-충돌">중복 등록과 충돌</h2>
<h3 id="자동-빈-등록-vs-자동-빈-등록">자동 빈 등록 vs 자동 빈 등록</h3>
<ul>
  <li>컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 <code class="language-plaintext highlighter-rouge">ConflictingBeanDefinitionException</code> 예외 발생</li>
</ul>

<h3 id="수동-빈-등록-vs-자동-빈-등록">수동 빈 등록 vs 자동 빈 등록</h3>
<ul>
  <li>수동 빈 등록이 우선권을 가짐</li>
  <li>수동 빈 등록시 남는 로그 : <code class="language-plaintext highlighter-rouge">Overriding bean definition for bean 'memoryMemberRepository' with a different
  definition: replacing</code></li>
  <li>최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌이 나면 오류가 발생하도록 기본값을 바꿈</li>
  <li>수동 빈 등록, 자동 빈 등록 오류 시 스프링 부트 에러 : <code class="language-plaintext highlighter-rouge">Consider renaming one of the beans or enabling overriding by setting
spring.main.allow-bean-definition-overriding=true</code></li>
</ul>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 5. 싱글톤 컨테이너</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/5-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 5. 싱글톤 컨테이너" /><published>2023-05-11T16:22:00+09:00</published><updated>2023-05-11T16:22:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/5-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/5-%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="웹-애플리케이션과-싱글톤">웹 애플리케이션과 싱글톤</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/b8c9055bd3c6a6894d9ef5b26105102f7d53a967">순수한 DI 컨테이너 코드</a></p>
<ul>
  <li>웹 애플리케이션으 보통 여러 고객이 동시에 요청</li>
  <li>스프링 없는 순수한 DI 컨테이너는 요청을 할 때마다 객체를 새로 생성
    <ul>
      <li>고객 트래픽이 초당 100이 나오면 초당 100개의 객체가 생성되고 소멸됨 -&gt; 메모리 낭비가 심함</li>
    </ul>
  </li>
  <li>싱글톤 패턴을 사용하여 해결
    <ul>
      <li>객체를 하나만 생성해서 공유</li>
    </ul>
  </li>
</ul>

<h2 id="싱글톤-패턴">싱글톤 패턴</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/befd0022892726a2425d6ef050e91b853ca452a1">싱글톤 패턴 코드</a></p>
<ul>
  <li>클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴</li>
  <li>static 영역에 객체 인스턴스를 미리 하나 생성해서 올려둔다.</li>
  <li><code class="language-plaintext highlighter-rouge">getInstance()</code>메서드를 통해서만 조회 가능</li>
  <li><code class="language-plaintext highlighter-rouge">private</code>생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 함</li>
</ul>

<h3 id="싱글톤-패턴-문제점">싱글톤 패턴 문제점</h3>
<ul>
  <li>싱글톤 패턴을 구현하는 코드 자체가 많이 들어감</li>
  <li>의존관계상 클라이언트가 구체 클래스에 의존 -&gt; DIP 위반</li>
  <li>클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높음</li>
  <li>테스트하기 어려움</li>
  <li>내부 속성을 변경하거나 초기화하기 어려움</li>
  <li>private 생성자로 자식 클래스를 만들기 어려움</li>
  <li>유연성이 떨어짐</li>
</ul>

<h2 id="싱글톤-컨테이너">싱글톤 컨테이너</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/a9eba911d35eb9112423d9ca0a8781b6e4302b97">스프링 컨테이너 코드</a></p>
<ul>
  <li>스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리</li>
  <li>스프링 컨테이너는 싱글톤 컨테이너 역할을 함
    <ul>
      <li>싱글톤 레지스트리 : 싱글톤 객체를 생성하고 관리하는 기능</li>
    </ul>
  </li>
  <li>싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지 가능
    <ul>
      <li>싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 됨</li>
      <li>DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용 가능</li>
    </ul>
  </li>
</ul>

<h2 id="싱글톤-방식의-주의점">싱글톤 방식의 주의점</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/cc99cd8e4a5b42bc67c26e07290694b21cc623d7">stateful한 싱글톤 객체의 문제점 예시 코드</a></p>
<ul>
  <li>싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안됨</li>
  <li>무상태(stateless)로 설계해야 함
    <ul>
      <li>특정 클라이언트에 의존적인 필드가 있으면 안됨</li>
      <li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨</li>
      <li>가급적 읽기만 가능해야 함</li>
      <li>필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 함</li>
    </ul>
  </li>
  <li>스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있음</li>
</ul>

<h2 id="configuration과-싱글톤">@Configuration과 싱글톤</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/86afc4aff259450441689ed86ab8c03874b96e9d">코드</a></p>
<ul>
  <li>자바 코드를 따라 <code class="language-plaintext highlighter-rouge">MemberRepository</code>가 3번 호출될 것으로 예상되자만 1번만 호출됨 -&gt; why?</li>
</ul>

<h2 id="configuration과-바이트코드-조작의-마법">@Configuration과 바이트코드 조작의 마법</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/c17e6f38df24b79475a233f84f72355428ca8a7c">코드</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Configuration</code>을 적용하면 CGLIB라는 바이트코드 조작 라이브러리를 사용하여 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고 그 클래스를 스프링 빈으로 등록</li>
  <li><code class="language-plaintext highlighter-rouge">@Bean</code>이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어짐</li>
  <li>싱글톤 보장</li>
</ul>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 4. 스프링 컨테이너와 스프링 빈</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 4. 스프링 컨테이너와 스프링 빈" /><published>2023-05-11T15:43:00+09:00</published><updated>2023-05-11T15:43:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="스프링-컨테이너">스프링 컨테이너</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//스프링 컨테이너 생성</span>
<span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ApplicationContext</code>는 인터페이스로 구현체에 따라 XML 또는 애노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만들 수 있다.</li>
</ul>

<h2 id="스프링-컨테이너-생성-과정">스프링 컨테이너 생성 과정</h2>
<ol>
  <li>스프링 컨테이너 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">new AnnotationConfigApplicationContext(AppConfig.class)</code></li>
      <li>구성 정보 지정 (<code class="language-plaintext highlighter-rouge">AppConfig.class</code>)</li>
    </ul>
  </li>
  <li>스프링 빈 등록
    <ul>
      <li>파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈 등록</li>
      <li><strong>빈 이름</strong>
        <ul>
          <li>메서드 이름을 사용</li>
          <li>직접 부여하는 방법 : <code class="language-plaintext highlighter-rouge">@Bean(name="beanName")</code></li>
          <li>항상 다른 이름을 부여해야 함
            <ul>
              <li>같은 이름을 부여하면, 다른 빈이 무시되거나 기존 빈을 덮어거리거나 설정에 따라 오류 발생</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>스프링 빈 의존관계 설정 - 준비</li>
  <li>스프링 빈 의존관계 설정 - 완료
    <ul>
      <li>스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입함</li>
    </ul>
  </li>
</ol>

<h2 id="컨테이너에-등록된-빈-조회">컨테이너에 등록된 빈 조회</h2>
<p><a href="https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextInfoTest.java">코드</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ac.getBeanDefinitionName()</code> : 스프링에 등록된 모든 빈 이름 조회</li>
  <li><code class="language-plaintext highlighter-rouge">ac.getBean()</code> : 빈 이름으로 빈 객체를 조회</li>
  <li><code class="language-plaintext highlighter-rouge">beanDefinition.getRole()</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ROLE_APPLICATION</code> : 일반적으로 사용자가 정의한 빈</li>
      <li><code class="language-plaintext highlighter-rouge">ROLE_INFRASTRUCTURE</code> : 스프링이 내부에서 사용하는 빈</li>
    </ul>
  </li>
</ul>

<h2 id="스프링-빈-조회---기본">스프링 빈 조회 - 기본</h2>
<p><a href="https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextBasicFindTest.java">코드</a></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ac.getBean(빈이름, 타입)</code></li>
  <li><code class="language-plaintext highlighter-rouge">ac.getBean(타입)</code></li>
  <li>조회 대상인 스프링 빈이 없으면 <code class="language-plaintext highlighter-rouge">NoSuchBeanDefinitionException</code> 발생</li>
  <li>구체 타입으로 조회하면 변경시 유연성이 떨어짐 -&gt; 권장 X</li>
</ul>

<h2 id="스프링-빈-조회---동일한-타입이-둘-이상">스프링 빈 조회 - 동일한 타입이 둘 이상</h2>
<p><a href="https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextSameBeanFindTest.java">코드</a></p>
<ul>
  <li>타입으로 조회시 같은 타입의 빈이 둘 이상이면 <code class="language-plaintext highlighter-rouge">NoUniqueBeanDefinitionException</code> 발생</li>
  <li>빈 이름을 지정하여 해결</li>
  <li><code class="language-plaintext highlighter-rouge">ac.getBeansOfType(빈타입)</code> : 해당 타입의 모든 빈 조회</li>
</ul>

<h2 id="스프링-빈-조회---상속-관계">스프링 빈 조회 - 상속 관계</h2>
<p><a href="https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextExtendsFindTest.java">코드</a></p>
<ul>
  <li>부모 타입으로 조회하면, 자식 타입도 함께 조회됨</li>
  <li><code class="language-plaintext highlighter-rouge">Object</code> 타입으로 조회하면, 모든 스프링 빈 조회됨</li>
</ul>

<h2 id="beanfactory와-applicationcontext">BeanFactory와 ApplicationContext</h2>
<p><code class="language-plaintext highlighter-rouge">AnnotationConfigApplicationContext</code> -&gt; <code class="language-plaintext highlighter-rouge">ApplicationContext</code>(interface) -&gt; <code class="language-plaintext highlighter-rouge">BeanFactroy</code>(interface)</p>

<h3 id="beanfactory">BeanFactory</h3>
<ul>
  <li>스프링 컨테이너의 최상위 인터페이스</li>
  <li>스프링 빈을 관리하고 조회하는 역할</li>
  <li><code class="language-plaintext highlighter-rouge">getBean()</code> 을 제공</li>
</ul>

<h3 id="applicationcontext">ApplicationContext</h3>
<ul>
  <li>BeanFactory 기능을 모두 상속받아 제공</li>
  <li>빈을 관리하고 조회하는 기능 뿐 아니라 수 많은 부가기능 제공
    <ul>
      <li><code class="language-plaintext highlighter-rouge">MessageSource</code> : 국제화 기능
        <ul>
          <li>한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">EnvironmentCapable</code> : 환경변수
        <ul>
          <li>로컬, 개발, 운영 등을 구분해서 처리</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code> : 애플리케이션 이벤트
        <ul>
          <li>이벤트를 발행하고 구독하는 모델을 편리하게 지원</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ResourceLoader</code> : 편리한 리소스 조회
        <ul>
          <li>파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="다양한-설정-형식-지원---자바-코드-xml">다양한 설정 형식 지원 - 자바 코드, XML</h2>

<h3 id="애노테이션-기반-자바-코드-설정-사용">애노테이션 기반 자바 코드 설정 사용</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AnnotationConfigApplicationContext</code>를 사용하여 자바 코드로된 설정 정보를 넘기면 됨</li>
  <li>AppConfig.java
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Configuration</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    
      <span class="nd">@Bean</span>
      <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span>
      <span class="o">}</span>
    
      <span class="nd">@Bean</span>
      <span class="kd">public</span> <span class="nc">MemoryMemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryMemberRepository</span><span class="o">();</span>
      <span class="o">}</span>
    
      <span class="nd">@Bean</span>
      <span class="kd">public</span> <span class="nc">OrderService</span> <span class="nf">orderService</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">(),</span> <span class="n">discountPolicy</span><span class="o">());</span>
      <span class="o">}</span>
    
      <span class="nd">@Bean</span>
      <span class="kd">public</span> <span class="nc">DiscountPolicy</span> <span class="nf">discountPolicy</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">RateDiscountPolicy</span><span class="o">();</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="xml-설정-사용">XML 설정 사용</h3>
<ul>
  <li>최근에는 스프링 부트를 사용하면서 거의 사용하지 않고, 레거시 프로젝트들이 XML로 되어 있음</li>
  <li><code class="language-plaintext highlighter-rouge">GenericXmlApplicationContext</code>를 사용하여 xml 설정 파일을 넘기면 됨</li>
  <li>appConfig.xml
    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
  <span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
         <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>
    
      <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberService"</span> <span class="na">class=</span><span class="s">"hello.core.member.MemberServiceImpl"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"memberRepository"</span> <span class="na">ref=</span><span class="s">"memberRepository"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/bean&gt;</span>
    
      <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberRepository"</span> <span class="na">class=</span><span class="s">"hello.core.member.MemoryMemberRepository"</span><span class="nt">/&gt;</span>
    
      <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"orderService"</span> <span class="na">class=</span><span class="s">"hello.core.order.OrderServiceImpl"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"memberRepository"</span> <span class="na">ref=</span><span class="s">"memberRepository"</span><span class="nt">/&gt;</span>
          <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"discountPolicy"</span> <span class="na">ref=</span><span class="s">"discountPolicy"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/bean&gt;</span>
    
      <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"discountPolicy"</span> <span class="na">class=</span><span class="s">"hello.core.discount.RateDiscountPolicy"</span><span class="nt">/&gt;</span>
    
  <span class="nt">&lt;/beans&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="스프링-빈-설정-메타-정보---beandefinition">스프링 빈 설정 메타 정보 - BeanDefinition</h2>
<p><a href="https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beandefinition/BeanDefinitionTest.java">코드</a></p>
<ul>
  <li>BeanDefinitionReader를 사용하여 설정 정보를 읽고 BeanDefinition 생성</li>
  <li><code class="language-plaintext highlighter-rouge">@Bean</code> 또는 <code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code> 하나 당 메타 정보가 생성됨</li>
  <li>스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈 생성</li>
  <li>BeamDefinition 정보
    <ul>
      <li>BeanClassName : 생성할 빈의 클래스 명</li>
      <li>factoryBeanName : 팩토리 역할의 빈을 사용할 경우 이름</li>
      <li>factoryMethodName : 빈을 생성할 팩토리 메서드 지정</li>
      <li>Scope : 싱글톤</li>
      <li>lazyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때까지 최대한 생성을 지연처리하는지 여부</li>
      <li>initMethodName : 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명</li>
      <li>DestroyMethodName : 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명</li>
      <li>Constructor arguments, Properties : 의존관계 주입에서 사용</li>
    </ul>
  </li>
</ul>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 3. 객체 지향 원리 적용</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/3-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%9B%90%EB%A6%AC-%EC%A0%81%EC%9A%A9/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 3. 객체 지향 원리 적용" /><published>2023-05-02T02:32:00+09:00</published><updated>2023-05-02T02:32:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/3-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%9B%90%EB%A6%AC-%EC%A0%81%EC%9A%A9</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/3-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%9B%90%EB%A6%AC-%EC%A0%81%EC%9A%A9/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="정률-할인-기능-추가">정률 할인 기능 추가</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/1dcdef32a6631c849cb4226f30115df29299876e">코드</a></p>
<ul>
  <li>문제점
    <ul>
      <li>할인 정책을 변경하려면 클라이언트인 <code class="language-plaintext highlighter-rouge">OrderServiceImpl</code> 코드를 고쳐야 함
        <ul>
          <li>Before : <code class="language-plaintext highlighter-rouge">private final DiscountPolicy discountPolicy = new FixDiscountPolicy();</code></li>
          <li>After : <code class="language-plaintext highlighter-rouge">private final DiscountPolicy discountPolicy = new RateDiscountPolicy();</code></li>
          <li>OCP 위반</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">OrderServiceImpl</code> 클래스는 인터페이스인 <code class="language-plaintext highlighter-rouge">DiscountPolicy</code> 뿐만 아니라 구체 클래스인 <code class="language-plaintext highlighter-rouge">FixDiscountPolicy</code>와 <code class="language-plaintext highlighter-rouge">RateDiscountPolicy</code>에도 의존
        <ul>
          <li>DIP 위반</li>
        </ul>
      </li>
      <li>구현체 없이는 코드를 실행할 수 없음</li>
    </ul>
  </li>
  <li>구현 객체를 대신 생성하고 주입해주는 클래스 필요</li>
</ul>

<h2 id="관심사의-분리">관심사의 분리</h2>
<h3 id="appconfig의-등장">AppConfig의 등장</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/2b03ba6285cfc52982e4f6bd79858b3479705f0c">코드</a></p>
<ul>
  <li>애플리케이션의 전체 동작 방식을 구성하기 위해 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스</li>
</ul>

<h3 id="appconfig-리팩터링">AppConfig 리팩터링</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/c880c1fc804ab870cbf456275b103989acf62b6e">코드</a></p>

<h3 id="iocinversion-of-control-제어의-역전">IoC(Inversion Of Control) 제어의 역전</h3>
<ul>
  <li>프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것</li>
  <li>AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너 또는 DI컨테이너라 함</li>
</ul>

<h3 id="스프링으로-전환">스프링으로 전환</h3>
<p><a href="https://github.com/dpdms529/SpringCore/commit/46bfdbb4e9842a2501f728ed071ec67a2cfc1b2d">코드</a></p>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry><entry><title type="html">[스프링 핵심 원리 기본편] 2. 예제 만들기</title><link href="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/2-%EC%98%88%EC%A0%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[스프링 핵심 원리 기본편] 2. 예제 만들기" /><published>2023-05-01T15:56:00+09:00</published><updated>2023-05-01T15:56:00+09:00</updated><id>https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/2-%EC%98%88%EC%A0%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="https://dpdms529.github.io/lectures/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/2-%EC%98%88%EC%A0%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<div class="jekyll-linkpreview-wrapper">
  <div class="jekyll-linkpreview-wrapper-inner">
    <div class="jekyll-linkpreview-content">
      <div class="jekyll-linkpreview-image">
        <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">
          <img src="https://cdn.inflearn.com/public/courses/325969/cover/2868c757-5886-4508-a140-7cb68a83dfd8/325969-eng.png" />
        </a>
      </div>

      <div class="jekyll-linkpreview-body">
        <h2 class="jekyll-linkpreview-title">
          <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank">스프링 핵심 원리 - 기본편 - 인프런 | 강의</a>
        </h2>
        <div class="jekyll-linkpreview-description">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다.,  - 강의 소개 | 인프런</div>
      </div>
    </div>
    <div class="jekyll-linkpreview-footer">
      <a href="//www.inflearn.com" target="_blank">www.inflearn.com</a>
    </div>
  </div>
</div>

<h2 id="프로젝트-생성">프로젝트 생성</h2>
<p><img src="https://github.com/dpdms529/SpringCore/assets/60471550/394ab566-6d6a-4e7b-9691-0180b44866e5" alt="image" /></p>
<ul>
  <li>Project : Gradle - Groovy</li>
  <li>Language : Java</li>
  <li>Spring Boot : SNAPSHOT, RC, M 등이 붙지 않은 버전 중 가장 높은 것</li>
  <li>Packaging : Jar</li>
  <li>Project Metadata
    <ul>
      <li>Group : hello</li>
      <li>Artifact : core</li>
    </ul>
  </li>
  <li>Dependencies : X</li>
</ul>

<h3 id="스프링-부트-30">스프링 부트 3.0</h3>
<ul>
  <li>Java 17 이상을 사용</li>
  <li>javax -&gt; jakarta</li>
</ul>

<h2 id="회원-서비스">회원 서비스</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/78e571dfdbf770b4ade937acf439797b67fc47a9">구현 코드</a></p>

<p><a href="https://github.com/dpdms529/SpringCore/commit/577fa0e96dad172ed06b013f3ba670cca192da9a">테스트 코드</a></p>

<h2 id="주문--할인-서비스">주문 &amp; 할인 서비스</h2>
<p><a href="https://github.com/dpdms529/SpringCore/commit/a761d4eded9c3e597454f632124acf9078453b5e">구현 코드</a></p>

<p><a href="https://github.com/dpdms529/SpringCore/commit/fbb8befacfcbf509909cad9eed01acc74873cb44">테스트 코드</a></p>]]></content><author><name>Joy</name></author><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Lectures" /><category term="스프링 핵심 원리 기본편" /><category term="Spring" /></entry></feed>