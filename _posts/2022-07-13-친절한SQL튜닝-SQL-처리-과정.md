---
layout: single
title: "[친절한SQL튜닝] SQL 처리 과정"
excerpt: "SQL 처리 과정"
date: 2022-07-13T02:08:00+09:00
toc: true
toc_sticky: true
categories:
  - DB 
tags:
  - DB
  - SQL
  - 친절한SQL튜닝
---
** 
*이 글은 (주)디비안 조시형 대표님의 [친절한SQL튜닝](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791196395704) 강의와 책을 바탕으로 공부한 내용을 정리한 글입니다.*
**

## SQL 처리 과정
![image](https://user-images.githubusercontent.com/60471550/178516427-21674d3f-5ec9-4c66-b5f9-166c4eab1788.png)

### SQL Parsing
**SQL Parser**는 사용자가 던진 SQL을 가장 먼저 받아서 처리하는 엔진으로, SQL 문장을 이루는 개별 구성요소를 분석하고 토큰화하여 파싱 트리를 만든다.<br>
파싱에서 하는 일은 다음과 같이 3가지가 있다.
- Syntax 체크 : 문법적 오류 체크
  - 사용할 수 없는 키워드 사용 여부
  - 순서가 바르지 않거나 누락된 키워드 존재 여부
- Symantic 체크 : 의미적 오류 체크
  - 존재하지 않거나 권한 없는 오브젝트 참조 여부
  - 존재하지 않는 컴럼 참조 여부
- 해당 SQL 커서가 Shared Pool에 캐싱돼 있는지 체크
  - ASCII 텍스트에 대한 숫자값을 계산하고, 해싱 알고리즘을 사용해 매칭되는 SQL 커서를 찾음

### Optimization
**SQL Optimizer**는 다음과 같이 3가지 엔진으로 나뉜다.

|엔진|설명|||
|---|---|---|---|
|**Query Transformer**|사용자가 작성한 SQL을 최적화하기 쉬운 형태로 변환 |||
|**Plan Generator**|하나의 쿼리를 수행하는 데 후보군이 될만한 다양한 실행계획 생성|||
|**Estimator**| - 각 수행 단계의 선택도, 카디널리티, 비용 계산 $\Rightarrow$ 총 비용 계산<br> - 오브젝트 통계 활용 : 레코드 개수, 블록 수, 평균행 길이, 인덱스 깊이, 컬럼 분포, 클러스터링 팩터<br> - 시스템 통계 활용 : CPU 속도, Single Block Read Time, Multiblock Read Time 등<br> - 예상치|

### Row Source Generation
**SQL 실행계획**은 개념 수준이기 때문에 실제 실행 가능한 형태가 아니다. 따라서 실행 엔진이 실행할 수 있는 코드 또는 프로시저 형태의 **Row Source**로 만들어준다. Row Source는 레코드 집합을 순차적으로 처리하면서 사용자가 요구한 최종 결과 집합을 생성하는 제어 구조이다.

## 라이브러리 캐시(Library Cache)
![image](https://user-images.githubusercontent.com/60471550/178539999-fbe32948-7d71-49f4-9e74-d245673f681d.png)

**라이브러리 캐시**는 최적화 과정을 거친 SQL과 실행계획을 캐싱해두는 메모리 공간이다. System Global Area (SGA)는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간인데, 라이브러리 캐시는 SGA의 구성요소 중 하나이다.

## Soft Parsing vs. Hard Parsing
![image](https://user-images.githubusercontent.com/60471550/178547157-c378f064-3051-4e0a-9bab-41405768b9af.png)

사용자가 SQL문을 전달하면 DBMS는 SQL Parsing을 진행한 후 라이브러리 캐시에 해당 SQL과 실행계획이 있는지 확인한다. 해당 SQL과 실행계획이 캐시에 있다면 최적화 과정을 생략하고 바로 실행단계로 넘어가는데, 이것을 **Soft Parsing**이라고 한다. 라이브러리 캐시에서 해당 SQL을 찾을 수 없다면 최적화 과정을 통해 실행계획을 생성한 다음 실행하게 되는데, 이것을 **Hard Parsing**이라고 한다.

## SQL 최적화 과정이 무거운 이유
조인 순서, 조인 방식, 액세스 방식, 인덱스 스캔 방식 등에 따라 하나의 쿼리를 수행하는데 매우 다양한 액세스 경로가 존재한다. 또 수많은 딕셔너리와 통계정보를 읽어 모든 실행 경로의 비용을 계산해야 한다. 따라서 최적화 과정을 거치는 Hard Parsing은 매우 무거운 작업이며, CPU를 많이 소비한다.