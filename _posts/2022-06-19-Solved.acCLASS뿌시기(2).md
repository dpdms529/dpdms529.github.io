---
layout: single
title: "[솔크뿌] Solved.ac CLASS 뿌시기(2)"
excerpt: "CLASS 3 : p11726, p2579, p9461, p11724, p11727, p1541"
date: 2022-06-19T23:38:00+09:00
toc: true
toc_sticky: true
categories:
  - Algorithm
  - 솔크뿌
tags:
  - Algorithm
  - JAVA
  - 솔크뿌
---

## 11726번 - 2×n 타일링
문제 링크 : [https://www.acmicpc.net/problem/11726](https://www.acmicpc.net/problem/11726)

![image](https://user-images.githubusercontent.com/60471550/174442137-80442a26-079a-4a45-b0df-46da2d16a5ee.png)

```java
import java.io.*;

public class p11726 {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // n : 직사각형의 가로 길이
        int n = Integer.parseInt(br.readLine());
        
        // arr : 2 x i 크기의 직사각형을 1 x 2 또는 2 x 1 타일로 채우는 방법의 수를 가지는 배열 
        int[] arr = new int[n+1];
        arr[0] = 1;
        arr[1] = 1;
        for(int i = 2;i<=n;i++){
            // 2 x i 크기의 직사각형을 1 x 2 또는 2 x 1 타일로 채우는 방법의 수는 arr[i-1] + arr[i-2]
            // 2 x n 크기의 직사각형을 채우는 방법의 수를 10007로 나눈 나머지를 출력해야하므로 arr[i]는 아래와 같이 구함 
            arr[i] = (arr[i-1] + arr[i-2]) % 10007;
        }
        
        // arr[n] 출력
        System.out.println(arr[n]);

    }
}
```

## 2579번 - 계단 오르기
문제 링크 : [https://www.acmicpc.net/problem/2579](https://www.acmicpc.net/problem/2579)

![image](https://user-images.githubusercontent.com/60471550/174449840-339f6e98-bfd7-4914-ad40-1f50fb63846d.png)
![image](https://user-images.githubusercontent.com/60471550/174449851-1fab0378-3d12-4809-8e62-33af6029317a.png)

```java
import java.io.*;

public class p2579 {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // n : 계단의 개수
        int n = Integer.parseInt(br.readLine());

        // arr :  각 계단에 쓰인 점수를 가지고 있는 배열
        int[] arr = new int[n+1];

        // dp : 각 계단을 밟을 때 얻을 수 있는 최고 점수를 가지는 배열
        int[] dp = new int[n+1];

        // 계단에 쓰여 있는 점수 arr에 저장
        for(int i = 1;i<=n;i++){
            arr[i] = Integer.parseInt(br.readLine());
        }

        // 첫번째 계단을 밟을 때 얻을 수 있는 최대 점수는 첫번째 계단에 적힌 점수
        dp[1] = arr[1];
        if(n>=2){
            // 두번째 계단을 밟을 때 얻을 수 있는 최대 점수는 첫번째 계단에 적힌 점수 + 두번째 계단에 적힌 점수
            dp[2] = arr[1] + arr[2];
            // 세번째 계단 이상부터 얻을 수 있는 최대 점수는 dp[i-2] + arr[1]와 dp[i-3] + arr[i-1] + arr[i] 중 더 큰 수
            for(int i = 3;i<=n;i++){
                dp[i] = Math.max(dp[i-2] + arr[i], dp[i-3] + arr[i-1] + arr[i]);
            }
        }

        // dp[n] 출력
        System.out.println(dp[n]);
    }
}
```

## 9461번 - 파도반 수열
문제 링크 : [https://www.acmicpc.net/problem/9461](https://www.acmicpc.net/problem/9461)

![image](https://user-images.githubusercontent.com/60471550/174452452-4723b549-fab6-42c2-a66c-ccd468c178da.png)

```java
import java.io.*;

public class p9461 {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // t : 테스트 케이스 개수
        int t = Integer.parseInt(br.readLine());

        // arr : 파도반 수열 P(N)값을 가지는 배열
        long[] arr = new long[100];

        // P(1)부터 P(3)의 값은 1
        for(int i = 0;i<3;i++){
            arr[i] = 1;
        }

        // N>=4일 때는 P(i) = P(i-3) + P(i-2)
        for(int i = 3;i<100;i++){
            arr[i] = arr[i-3] + arr[i-2];
        }

        // t만큼 n을 입력받아 P(n) 출력
        for(int i = 0;i<t;i++){
            int n = Integer.parseInt(br.readLine());
            System.out.println(arr[n-1]);
        }
    }
}
```  

## 11724번 - 연결 요소의 개수
문제 링크 : [https://www.acmicpc.net/problem/11724](https://www.acmicpc.net/problem/11724)

![image](https://user-images.githubusercontent.com/60471550/174486138-a2cf5bb0-43f5-456e-9963-ee6e905da1b5.png)

```java
import java.util.*;
import java.io.*;

public class p11724 {
    // n : 정점의 개수
    public static int n;

    // m : 간선의 개수
    public static int m;

    // graph : 각 정점에 연결된 정점들을 나타내는 이중 리스트
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();

    // visited : 정점 방문 여부를 나타내는 배열
    public static boolean[] visited;

    public static void bfs(int start){
        // 큐 생성
        Queue<Integer> queue = new LinkedList<>();

        // 시작 정점 방문 처리 후 큐에 삽입
        visited[start] = true;
        queue.offer(start);

        // 큐가 빌 때까지 반복
        while(!queue.isEmpty()){
            // 큐에서 정점 추출
            int x = queue.poll();

            // 해당 정점에 연결된 정점 중 방문한적 없는 정점들은 방문 처리 후 큐에 삽입
            for(int i = 0;i<graph.get(x).size();i++){
                int y = graph.get(x).get(i);
                if(!visited[y]){
                    visited[y] = true;
                    queue.offer(y);
                }
            }
        }
    }

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        // n, m값 입력
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        // visited 배열 생성
        visited = new boolean[n];

        // graph 초기화
        for(int i = 0;i<n;i++){
            graph.add(new ArrayList<>());
        }

        // graph 값 입력
        for(int i = 0;i<m;i++){
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken()) - 1;
            int v = Integer.parseInt(st.nextToken()) - 1;
            graph.get(u).add(v);
            graph.get(v).add(u);
        }

        // cnt : 연결 요소 개수
        int cnt = 0;

        // 방문하지 않은 정점일 경우 bfs()를 실행하여 연결된 정점을 모두 방문 처리 후 cnt 값 1 증가
        for(int i = 0;i<n;i++){
            if(!visited[i]){
                bfs(i);
                cnt++;
            }
        }

        // cnt 출력
        System.out.println(cnt);
    }
}
``` 

## 11727번 - 2×n 타일링 2
문제 링크 : [https://www.acmicpc.net/problem/11727](https://www.acmicpc.net/problem/11727)

![image](https://user-images.githubusercontent.com/60471550/174486254-ecc248a2-e71a-4d82-96aa-96e4358bb1b3.png)

```java
import java.io.*;

public class p11727 {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // n : 직사각형 가로 길이
        int n = Integer.parseInt(br.readLine());

        // dp : 2 x i 크기의 직사각형을 타일로 채우는 방법의 수를 가지는 배열
        int[] dp = new int[1000];

        // 2 x 1 크기의 직사각형을 타일로 채우는 방법은 1가지
        dp[0] = 1;

        // 2 X 2 크기의 직사각형을 타일로 채우는 방법은 3가지
        dp[1] = 3;
        
        // n>=3인 경우 직사각형을 타일로 채우는 방법의 수는 dp[i-1] + 2*dp[i-2]
        for(int i = 2;i<n;i++){
            dp[i] = (dp[i-1] + 2*dp[i-2]) % 10007;
        }
        
        // dp[n-1] 출력
        System.out.println(dp[n-1]);
    }
}
``` 

## 1541번 - 잃어버린 괄호
문제 링크 : [https://www.acmicpc.net/problem/1541](https://www.acmicpc.net/problem/1541)

![image](https://user-images.githubusercontent.com/60471550/174486341-67ffad4a-b2c9-48a5-8bc1-3b255f1e3c9f.png)

```java
import java.io.*;

public class p1541 {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // input : 주어진 식을 -를 기준으로 나눈 것
        String[] input = br.readLine().split("-");

        // result : 주어진 식의 최소값
        int result = 0;

        // input의 요소가 +를 포함한 식이면 + 기준으로 나눠 구해진 숫자들을 모두 더해 그 값을 sum에 저장
        // input의 요소가 숫자면 그 값을 sum에 저장
        // i = 0일 경우 result에 sum을 더해주고, 아닐 경우 result에 sum을 빼준다.
        for(int i = 0;i<input.length;i++){
            int sum = 0;
            if(input[i].contains("+")){
                String[] arr = input[i].split("\\+");
                for(int j = 0;j<arr.length;j++){
                    sum += Integer.parseInt(arr[j]);
                }
            }else{
                sum += Integer.parseInt(input[i]);
            }
            if(i == 0) result += sum;
            else result -= sum;
        }

        // result 출력
        System.out.println(result);
    }
}
``` 