---
layout: single
title: "[친절한SQL튜닝] 라이브러리 캐시 구조 및 커서 공유"
excerpt: "라이브러리 캐시 구조 및 커서 공유"
date: 2022-07-14T16:08:00+09:00
toc: true
toc_sticky: true
categories:
  - DB 
tags:
  - DB
  - SQL
  - 친절한SQL튜닝
---
** 
*이 글은 (주)디비안 조시형 대표님의 [친절한SQL튜닝](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791196395704) 강의와 책을 바탕으로 공부한 내용을 정리한 글입니다.*
**

## 커서(Cursor)
![image](https://user-images.githubusercontent.com/60471550/178670778-26cf0a52-6057-4aea-a0f2-e618be0f90fb.png)
커서에는 공유 커서, 세션 커서, 애플리케이셔 커서가 있다. 먼저 **공유 커서**는 라이브러리 캐시의 공유되어 있는 Shared SQL Area이다. [이전 게시물](https://dpdms529.github.io/db/%EC%B9%9C%EC%A0%88%ED%95%9CSQL%ED%8A%9C%EB%8B%9D-SQL-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95/#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%BA%90%EC%8B%9Clibrary-cache)에서 말했다시피 SQL을 수행하면 해당 SQL이 라이브러리 캐시에 공유되어 있는지 확인하여 없다면 최적화 과정을 거쳐 실행 계획을 만들고 라이브러리 캐시에 공유하는데 이것이 공유 커서이다.<br>
다음으로 **세션 커서**는 Program Global Area(PGA)에 할당된 Private SQL Area로, 공유 커서에 대한 인스턴스이다. 공유 커서는 객체지향프로그래밍에서의 클래스와 같이 SQL을 수행하는데 필요한 루틴을 정의한 것이다. JAVA에서 `new`를 사용하여 객체를 할당하는 것처럼 오라클에서도 커서를 오픈하면 공유 커서를 인스턴스화하여 PGA에 커서를 위한 메모리 공간을 할당하고 실제 데이터 추출을 할 수 있도록 준비작업을 한다.<br>
마지막으로 **애플리케이션 커서**는 클라이언트 환경에서 세션 커서를 가리키는 핸들이다.

## 커서 공유
커서 공유에서 말하는 커서는 공유 커서를 뜻한다. 라이브러리 캐시에 실행하고자 하는 SQL이  사용함으로써 최적화 과정을 거치지 않고 쿼리를 반복하여 재사용할 수 있다.

## 이름 없는 SQL 문제
사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때 이름을 부여하며 컴파일해서 딕셔너리에 저장되어 있다. 이는 사용자가 명시적으로 Drop하기 전까지는 영구 보관하기 때문에 계속해서 공유하고 재사용할 수 있다.<br>
이와 다르게 SQL은 전체 SQL 텍스트 자체가 이름이다. 때문에 텍스트 중 하나라도 수정하는 순간 다른 객체가 생긴다. SQL은 개발 중 수시로 변경이 일어나며 일회성 SQL도 존재하기 때문에 이를 모두 저장하려면 많은 저장 공간이 필요할 것이다. 따라서 SQL은 딕셔너리에 저장하지 않고 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 공유 & 재사용할 수 있다. 캐시에 공간이 부족해지면 버려지고 다시 실행할 때 최적화 과정을 통해 다시 캐싱된다.

## 공유 불가능한 SQL
```sql
SELECT * FROM EMP WHERE EMPNO = 8000;
select * from emp where empno = 8000;
select /* comment */ * from emp where empno = 8000;
```
위의 SQL들은 모두 같은 SQL이다. 하지만 텍스트가 다르기 때문에 공유되지 못하고 각각 최적화 과정을 거쳐 라이브러리 캐시에 캐싱된다.

## 공유 가능한 SQL
```sql
SELECT * FROM USER WHERE ID = 'dpdms529';
SELECT * FROM USER WHERE ID = 'twokst';
```
위의 두 SQL은 같은 역할을 수행하지만 찾으려는 아이디가 다르기 때문에 각각 최적화 과정을 거쳐야 한다. 하지만 **바인드 변수**를 사용하여 아래와 같이 SQL을 작성하면 SQL을 공유하여 재사용할 수 있다.
```sql
SELECT * FORM USER WHERE ID = :ID;
```

## 바인드 변수의 부작용과 해법
바인딩은 실행계획이 생성된 이후에 이루어진다. 때문에 옵티마이저가 실행계획을 세울 때 컬럼분포를 활용할 수 없게 된다. 예를 들어 아파트 매물을 검색한다고 할 때 서울이나 경기도에는 아파트 매물이 많으므로 인덱스를 찾고 테이블을 찾아가는 것보다 테이블을 full scan하는 것이 더 효율적일 것이다. 반대로 강원도나 제주도 등 아파트 매물이 적은 지역을 검색할 경우에는 인덱스를 활용하는 것이 더 효율적이다. 하지만 바인드 변수를 사용할 경우 실행계획을 생성할 때에는 바인드 변수에 어떤 값이 들어올지 알 수 없기 때문에 옵티마이저는 평균값을 계산하여 평균값 기준으로 실행계획을 세운다. 그렇기 때문에 Table scan을 하기로 결정한 상태에서 바인드 변수 값으로 제주도가 들어오거나, Index scan을 하기로 결정한 상태에서 바인드 변수 값으로 서울이 들어온 경우 비효율적이게 된다.
![image](https://user-images.githubusercontent.com/60471550/178921372-b4de5273-a740-42f0-8640-fa15008d32b2.png)

이러한 경우 데이터 분포나 조회 범위에 따라 실행계획을 분리하면 문제를 해결할 수 있다. 아파트 매물이 많은 서울과 경기도에서 검색하는 쿼리와 그 외의 지역에서 검색하는 쿼리를 따로 작성하여 `UNION ALL`로 합쳐주는 것이다.
```sql
SELECT /*+FULL(A)*/ *
FROM 아파트매물 A
WHERE :CITY IN ('서울시','경기도')
AND 도시 = :CITY
UNION ALL
SELECT /*+ INDEX(A IDX01) */ *
FROM 아파트매물 A
WHERE :CITY NOT IN ('서울시','경기도')
AND 도시 = :CITY;
```
또는 라이브러리 캐시 부하 가능성이 낮은 경우 바인드 변수 대신 Literal 상수 값을 사용하는 것이 오히려 더 나은 실행계획을 수립하는데 도움이 될 수 있다. Literal 상수값을 쓰는 것이 더 나은 경우는 다음과 같다. 
- 조건절 컬럼의 값 종류가 소수인 경우
- Batch 프로그램이나 DW, OLAP 등 정보계 시스템에서 사용되는 Long Running 쿼리
- OLTP성이더라도 사용빈도가 아주 낮은 쿼리