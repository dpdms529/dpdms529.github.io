---
layout: single
title: "[솔크뿌] Solved.ac CLASS 뿌시기(11)"
excerpt: "CLASS 4 : p9456, p5639"
date: 2022-09-5T10:00:00+09:00
toc: true
toc_sticky: true
categories:
  - Algorithm
  - 솔크뿌
tags:
  - Algorithm
  - Java
  - 솔크뿌
---
## 9465번 - 스티커

문제 링크 : [https://www.acmicpc.net/problem/9465](https://www.acmicpc.net/problem/9465)

![Untitled](https://user-images.githubusercontent.com/60471550/188341060-8a5b5c46-d258-4b7f-accb-5a82cfd432fd.png)


![Untitled 1](https://user-images.githubusercontent.com/60471550/188341045-d3661f82-2525-4436-8b08-24751f3a0b23.png)

### 풀이

- 선택 가능한 스티커
    - 오른쪽 대각선에 있는 스티커
    - 오른쪽으로 2칸 떨어져 있는 스티커 위, 아래 중 하나
- 첫번째 열부터 n-1번째 열까지 돌면서 위의 3가지 선택 가능한 스티커들과 현재 스티커의 값을 각각 더해 각 스티커 위치의 dp 배열 값과 비교하여 더 크면 그 값을 저장
- dp 마지막 열의 첫번째 행 값과 두번째 행 값을 비교하여 더 큰 값을 출력

### 코드

```java
package p9465;

import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        for(int tc = 0;tc<T;tc++){
            int n = Integer.parseInt(br.readLine());
            int[][] sticker = new int[2][n];
            int[][] dp = new int[2][n];
            for(int i = 0;i<2;i++){
                StringTokenizer st = new StringTokenizer(br.readLine());
                for(int j = 0;j<n;j++){
                    sticker[i][j] = Integer.parseInt(st.nextToken());
                }
            }

            dp[0][0] = sticker[0][0];
            dp[1][0] = sticker[1][0];

            for(int i = 0;i<n-1;i++){
                for(int j = 0;j<2;j++){
                    if(i<n-2) {
                        dp[j][i + 2] = Math.max(dp[j][i + 2], dp[j][i] + sticker[j][i + 2]);
                        dp[1-j][i + 2] = Math.max(dp[1-j][i + 2], dp[j][i] + sticker[1-j][i + 2]);
                    }
                    dp[1-j][i+1] = Math.max(dp[1-j][i+1], dp[j][i] + sticker[1-j][i+1]);
                }
            }

            System.out.println(Math.max(dp[0][n-1], dp[1][n-1]));

        }

    }
}
```

## 5639번 - 이진 검색 트리

문제 링크 : [https://www.acmicpc.net/problem/5639](https://www.acmicpc.net/problem/5639)

![Untitled](https://user-images.githubusercontent.com/60471550/188341177-90afe3c3-2d5e-490e-9139-a04a447a9700.png)


### 풀이

- 전위 순회 : 부모 → 왼쪽 자식 → 오른쪽 자식
- 후위 순회 : 왼쪽 자식 → 오른쪽 자식 → 부모
- 전위 순회하는 노드 값 입력 받으면서 트리 생성
    - 첫번째 입력되는 노드는 루트
    - 현재 노드보다 작은 값이 입력되면 왼쪽 자식 노드
    - 현재 노드보다 큰 값이 입력되면 어떤 노드의 오른쪽 자식 노드인지 찾아야 함
        - 입력값이 부모 노드 값보다 큰 경우를 모두 돌아보면서 부모 노드의 오른쪽 자식이 없을 경우 현재 노드를 부모 노드로 갱신
        - while 문이 끝난 후 현재 노드의 오른쪽 자식 노드 생성
- 생성된 트리를 후위 순회하며 값 출력

### 코드

```java
package p5639;

import java.io.*;

class Node{
    int value;
    Node parent;
    Node left;
    Node right;

    public Node(int value){
        this.value = value;
    }
}

public class Main {
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        Node root = new Node(Integer.parseInt(br.readLine()));
        Node node = root;
        String input = br.readLine();
        while(input != null && !input.isEmpty()){
            int num = Integer.parseInt(input);
            if(num < node.value){
                node.left = new Node(num);
                node.left.parent = node;
                node = node.left;
            }else{
                Node tmp = node;
                while(tmp != root && num > tmp.parent.value){
                    tmp = tmp.parent;
                    if(tmp.right == null){
                        node = tmp;
                    }
                }
                node.right = new Node(num);
                node.right.parent = node;
                node = node.right;
            }
            input = br.readLine();
        }
        postOrder(root);
    }

    static void postOrder(Node node){
        if(node.left != null) postOrder(node.left);
        if(node.right != null) postOrder(node.right);
        System.out.println(node.value);
    }
}
```