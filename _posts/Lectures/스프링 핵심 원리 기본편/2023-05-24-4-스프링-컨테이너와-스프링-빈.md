---
layout: single
title: "[스프링 핵심 원리 기본편] 4. 스프링 컨테이너와 스프링 빈"
excerpt: ""
date: "2023-05-24 17:51:00"
toc: true
toc_sticky: true
use_math: true
categories: [Lectures, 스프링 핵심 원리 기본편]
tags: [Lectures, 스프링 핵심 원리 기본편]
---
{% linkpreview "https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" %}

## 스프링 컨테이너 생성
```java
//스프링 컨테이너 생성
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```

`ApplicationContext`를 스프링 컨테이너라고 한다. `ApplicationContext`는 인터페이스이기 때문에 구현체를 지정해주어야 하는데, 읽어야 하는 설정 파일의 형식에 따라 적절한 구현체를 사용하면 된다. 설정 파일은 XML 기반으로 만들 수도 있고, 애노테이션 기반의 자바 클래스로 만들 수도 있다.

스프링 컨테이너의 생성 과정은 다음과 같다.

1. 스프링 컨테이너 생성
  - `new XXXApplicationContext(AppConfig.xxx)`
  - 스프링 컨테이너를 생성할 때는 생성자의 파라미터로 구성 정보를 지정해서 넣어주어야 한다.
2. 스프링 빈 등록
  - 스프링 컨테이너는 파라미터로 넘어온 설정 정보를 사용해서 스프링 빈을 등록한다.
  - 애노테이션 기반 자바 설정 클래스에서 빈 이름 설정
        - 기본으로는 메서드 이름을 사용한다.
        - `@Bean(name="beanName")` 애노테이션을 이렇게 붙여주면 빈 이름을 직접 설정할 수 있다.
        - 빈 이름이 중복되면 다른 빈이 무시되거나 기존 빈을 덮어버리거나 설정에 따라 오류가 발생하기 때문에 항상 다른 이름을 부여해야 한다.
3. 스프링 빈 의존관계 설정 - 준비
4. 스프링 빈 의존관계 설정 - 완료
  - 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입한다.

## 컨테이너에 등록된 빈 조회
{% linkpreview "https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextInfoTest.java" %}

- `ac.getBeanDefinitionName()` : 스프링에 등록된 모든 빈 이름 조회한다.
- `ac.getBean(beanDefinitionName)` : 빈 이름으로 빈 객체를 조회한다.
- `ac.getBeanDefinition(beanDefinitionName)` : 빈 이름으로 빈 설정 메타 정보를 조회한다.
- `beanDefinition.getRole()` : 빈의 역할을 조회한다.
  - `ROLE_APPLICATION` : 일반적으로 사용자가 정의한 빈
  - `ROLE_INFRASTRUCTURE` : 스프링이 내부에서 사용하는 빈

## 스프링 빈 조회
### 기본
{% linkpreview "https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextBasicFindTest.java" %}

스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법은 다음과 같다.
- `ac.getBean(빈이름, 타입)`
- `ac.getBean(타입)`

`getBean`을 통해 빈을 조회할 때 조회 대상인 스프링 빈이 없으면 `NoSuchBeanDefinitionException` 발생한다. 

구체 타입으로도 조회가 가능하지만 구체 타입은 변경이 가능하기 때문에 변경할 때마다 `getBean()`의 파라미터로 들어가는 타입도 바꿔줘야하므로 유연성이 떨어져 권장하지 않는다.

### 동일한 타입이 둘 이상
{% linkpreview "https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextSameBeanFindTest.java" %}

타입으로 조회시 같은 타입의 빈이 둘 이상이면`NoUniqueBeanDefinitionException`이 발생한다. 이 때는 빈 이름을 지정해주면 된다. 

특정 타입의 모든 빈을 조회하고 싶을 때는 `ac.getBeansOfType(빈타입)`을 써주면 된다.

### 상속 관계
{% linkpreview "https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beanfind/ApplicationContextExtendsFindTest.java" %}

부모 타입으로 조회하면, 자식 타입도 함께 조회된다. 그래서 모든 자바 객체의 최고 부모인 `Object` 타입으로 조회하면, 모든 스프링 빈이 조회된다.

## BeanFactory와 ApplicationContext
`XXXApplicationContext` -> `ApplicationContext` -> `BeanFactroy`

### BeanFactory
`BeanFactory`는 스프링 컨테이너의 최상위 인터페이스로 스프링 빈을 관리하고 조회(`getBean()`)하는 역할을 한다.

### ApplicationContext
`ApplicationContext`는 `BeanFactory`의 기능을 모두 상속받기 때문에 빈을 관리하고 조회하는 기능을 제공하며, 그 외의 부가기능들도 제공한다.

`ApplicationContext`가 제공하는 부가기능은 다음과 같다.
- `MessageSource` : 국제화 기능
  - 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
- `EnvironmentCapable` : 환경변수
  - 로컬, 개발, 운영 등을 구분해서 처리
- `ApplicationEventPublisher` : 애플리케이션 이벤트
  - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
- `ResourceLoader` : 편리한 리소스 조회
  - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

## 다양한 설정 형식 지원 - 자바 코드, XML

### 애노테이션 기반 자바 코드 설정 사용
`new AnnotationConfigApplicationContext(AppConfig.class)`를 사용하여 다음과 같이 자바 코드로된 설정 정보를 넘기면 된다.

**AppConfig.java**
```java
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService(){
        return new MemberServiceImpl(memberRepository());
    }

    @Bean
    public MemoryMemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    @Bean
    public OrderService orderService(){
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    @Bean
    public DiscountPolicy discountPolicy(){
        return new RateDiscountPolicy();
    }
}
```

### XML 설정 사용
최근에는 스프링 부트를 사용하면서 XML 기반 설정 파일은 거의 사용하지 않지만 기존의 레거시 프로젝트에서 많이 사용한다. 

`new GenericXmlApplicationContext("appConfig.xml")`를 사용하여 다음과 같은 xml 설정 파일을 넘기면 된다.

**appConfig.xml**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="memberService" class="hello.core.member.MemberServiceImpl">
        <constructor-arg name="memberRepository" ref="memberRepository"/>
    </bean>

    <bean id="memberRepository" class="hello.core.member.MemoryMemberRepository"/>

    <bean id="orderService" class="hello.core.order.OrderServiceImpl">
        <constructor-arg name="memberRepository" ref="memberRepository"/>
        <constructor-arg name="discountPolicy" ref="discountPolicy"/>
    </bean>

    <bean id="discountPolicy" class="hello.core.discount.RateDiscountPolicy"/>

</beans>
```
  
## 스프링 빈 설정 메타 정보 - BeanDefinition
{% linkpreview "https://github.com/dpdms529/SpringCore/blob/main/src/test/java/hello/core/beandefinition/BeanDefinitionTest.java" %}

스프링은 설정 형식에 따라 `XXXBeanDefinitionReader`를 사용하여 설정 정보를 읽어 `BeanDefinition`을 생성한다. `BeanDefinition`은 빈 설정 메타 정보로 `@Bean` 또는 `<bean>` 당 하나씩 생성된다. 스프링 컨테이너는 이 메타 정보를 기반으로 스프링 빈을 생성한다.

### BeanDefinition 정보
- `BeanClassName` : 생성할 빈의 클래스 명
  - 자바 설정 클래스를 사용하는 것과 같이 상위 클래스가 어떤 구체 클래스가 생성되어 들어올지 모르도록 하는 것을 `팩토리 패턴`이라고 하는데, 이와 같은 팩토리 역할의 빈을 사용하면 `BeanClassName`이 지정되지 않는다.
- `factoryBeanName` : 팩토리 역할의 빈을 사용할 경우 이름
- `factoryMethodName` : 빈을 생성할 팩토리 메서드 지정
- `Scope` : 싱글톤
- `lazyInit` : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때까지 최대한 생성을 지연처리하는지 여부
- `initMethodName` : 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
- `DestroyMethodName` : 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
- `Constructor arguments`, `Properties` : 의존관계 주입에서 사용
