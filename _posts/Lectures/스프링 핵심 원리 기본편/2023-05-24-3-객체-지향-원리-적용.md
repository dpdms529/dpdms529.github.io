---
layout: single
title: "[스프링 핵심 원리 기본편] 3. 객체 지향 원리 적용"
excerpt: ""
date: "2023-05-24 17:49:00"
toc: true
toc_sticky: true
use_math: true
categories: [Lectures, 스프링 핵심 원리 기본편]
tags: [Lectures, 스프링 핵심 원리 기본편]
---
{% linkpreview "https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" %}

## 정률 할인 기능 추가
{% linkpreview "https://github.com/dpdms529/SpringCore/commit/1dcdef32a6631c849cb4226f30115df29299876e" %}

할인 정책을 변경하려면 클라이언트인 `OrderServiceImpl` 코드를 다음과 같이 고쳐야 한다. 이는 OCP를 위반한다.
- Before : `private final DiscountPolicy discountPolicy = new FixDiscountPolicy();`
- After : `private final DiscountPolicy discountPolicy = new RateDiscountPolicy();`

또한 `OrderServiceImpl` 클래스는 인터페이스인 `DiscountPolicy` 뿐만 아니라 구체 클래스인 `FixDiscountPolicy`와 `RateDiscountPolicy`에도 의존하고 있다. 이는 DIP를 위반한다. 하지만 그렇다고 구현체 없이 인터페이스만 사용하면 코드를 실행할 수가 없다. 그렇기 때문에 구현 객체를 대신 생성하고 주입해주는 클래스가 필요하다.

## 관심사의 분리
{% linkpreview "https://github.com/dpdms529/SpringCore/commit/2b03ba6285cfc52982e4f6bd79858b3479705f0c" %}

{% linkpreview "https://github.com/dpdms529/SpringCore/commit/c880c1fc804ab870cbf456275b103989acf62b6e" %}

애플리케이션의 전체 동작 방식을 구성하기 위해 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스 `AppConfig`를 만들어준다. 

```java
//AppConfig
public class AppConfig {
  ...

  public OrderService orderService() {
    return new OrderServiceImpl(
      memberRepository(), 
      discountPolicy());
  }
  
  public MemberRepository memberRepository() {
    return new MemoryMemberRepository();
  }
  
  public DiscountPolicy discountPolicy() {
    return new FixDiscountPolicy();
  }

}

//OrderServiceImpl 생성자
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
  this.memberRepository = memberRepository;
  this.discountPolicy = discountPolicy;
}

//OrderApp
public static void main(String[] args){
  AppConfig appConfig = new AppConfig();
  OrderService orderService = appConfig.orderService();

  ...
}
```
`OrderService`는 어떤 구현체가 들어올지 알 필요 없이 `appConfig.orderService()`가 반환하는 구현체를 받으면 된다. 마찬가지로 `memberRepository`와 `discountPolicy`도 `AppConfig`에 설정된대로 `memberRepository()`와 `discountPolicy()`가 반환하는 구현체를 받으면 된다.

나중에 할인 정책을 `FixDiscountPolicy`에서 `RateDiscountPolicy`로 바꾼다고 해도 AppConfig에서 `discountPolicy()`에서 반환하는 구현체를 `RateDiscountPoicy`로만 바꿔주면 `OrderServiceImpl`의 코드를 수정하지 않고도 할인 정책을 바꿀 수 있다. 그리고 할인정책의 구현체에 의존하지 않아도 된다. 따라서 OCP와 DIP를 지킬 수 있다.

또 이전에는 `OrderServiceImpl`이 `memberRepository`와 `discountPolicy`의 구현체를 생성하는 역할도 했어야 했는데 이제는 주문 서비스 기능에만 집중하면 되기 때문에 책임이 명확해진다.

### IoC(Inversion Of Control, 제어의 역전) 
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 `제어의 역전(IoC)`라고 하며, `AppConfig`처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 `IoC 컨테이너` 또는 `DI 컨테이너`라고 한다.

### 스프링으로 전환
{% linkpreview "https://github.com/dpdms529/SpringCore/commit/46bfdbb4e9842a2501f728ed071ec67a2cfc1b2d" %}

`AppConfig` 클래스에 `@Configuration`을 붙여주면 스프링 컨테이너가 `AppConfig`의 정보를 읽어 `@Bean`이 붙은 메서드를 호출해서 반환된 객체를 스프링 컨테이너로 등록한다. 이렇게 등록된 객체를 `스프링 빈`이라고 한다.

이전에는 필요한 객체를 `AppConfig`를 통해 직접 조회했지만, 스프링을 사용하면 스프링 컨테이너를 통해서 필요한 스프링 빈을 찾아야 한다. 스프링 컨테이너는 `ApplicationContext`이며, 스프링 빈은 `applicationContext.getBean()`을 통해 찾을 수 있다.

여기까지의 내용만 보면 코드가 오히려 복잡해진 것 같다는 느낌이 들 것이다. 다음 포스팅에서 스프링 컨테이너를 사용하면 좋은 점을 알아보자.