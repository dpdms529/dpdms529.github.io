---
layout: single
title: "[친절한SQL튜닝] 1장 SQL 처리 과정과 I/O"
excerpt: "1장 SQL 처리 과정과 I/O"
date: 2022-07-07T03:57:00+09:00
toc: true
toc_sticky: true
categories:
  - DB 
  - 친절한SQL튜닝
tags:
  - DB
  - SQL
  - 친절한SQL튜닝
---

## 1.1 SQL 파싱과 최적화

### 구조적, 집합적,선언적 질의 언어

- SQL : 구조적, 집합적, 선언적 질의 언어
- SQL 옵티마이저 : 프로시저를 만들어내는 DBMS 내부 엔진
- SQL 최적화 : DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정

### SQL 최적화 과정

1. SQL 파싱
    - 파싱 트리 생성
    - Syntax 체크
    - Semantic 체크
2. SQL 최적화
    - 옵티마이저
    - 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로 생성하여 비교
    - 가장 효율적인 실행경로 선택
3. 로우 소스 생성
    - 로우 소스 생성기
    - 선택된 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅

### SQL 옵티마이저

- 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS 핵심 엔진
- 최적화 단계
    1. 실행계획 후보군 찾기
    2. 데이터 딕셔너리에 수집해 둔 시스템 및 오브젝트 통계정보를 이용해 각 실행계획의 예상비용 산정
    3. 최저 비용을 나타내는 실행계획 선택

### 실행계획과 비용

- 실행계획 : SQL옵티마이저가 생성한 처리 절차를 사용자가 확인할 수 있게 트리 구조로 표현한 것
- 통계정보 수집 명령 : `exec dbms_status.gather_table_status(사용자, 테이블);`
- 실행 계획 확인 : `Ctrl + E`
- 비용 : 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간
- 옵티마이저는 비용을 근거로 실행계획을 선택
- But 비용은 예상치이기 때문에 실측치와 차이가 존재함 → 옵티마이저의 선택이 최선이 아님

### 옵티마이저 힌트

- 옵티마이저보다 더 효율적인 액세스 경로를 안다면 개발자가 옵티마이저 힌트를 통해 데이터 액세스 경로를 바꿀 수 있음
- 힌트 사용법 : `/*+ 힌트 */`

**주의사항**

- 힌트 안에 인자를 나열할 때는 ,(콤마) 사용 가능 / 힌트와 힌트 사이에는 사용 불가능
- 테이블을 지정할 때 스키마명까지 명시하면 안됨
- 테이블의 ALIAS를 지정했다면 힌트에도 ALIAS 사용해야 함

**자주 사용하는 힌트 목록**

| 분류 | 힌트 | 설명 |
| --- | --- | --- |
| 최적화 목표 | ALL_ROWS | 전체 처리속도 최적화 |
|  | FIRST_ROWS(N) | 최초 N건 응답속도 최적화 |
| 액세스 방식 | FULL | Table Full Scan으로 유도 |
|  | INDEX | Index Scan으로 유도 |
|  | INDEX_DESC | Index를 역순으로 스캔하도록 유도 |
|  | INDEX_FFS | Index Fast Full Scan으로 유도 |
|  | INDEX_SS | Index Skip Scan으로 유도 |
| 조인순서 | ORDERED | FROM절에 나열된 순서대로 조인 |
|  | LEADING | LEADING 힌트 괄호에 길술한 순대로 조인 |
|  | SWAP_JOIN_INPUTS | 해시 조인 시, BUILD INPUT을 명시적으로 선택 |
| 조인방식 | USE_NL | NL조인으로 유도 |
|  | USE_MERGE | 소트 머지 조인으로 유도 |
|  | USE_HASH | 해시 조인으로 유도 |
|  | NL_SJ | NL 세미조인으로 유도 |
|  | MERGE_SJ | 소트 머지 세미조인으로 유도 |
|  | HASH_SJ | 해시 세미조인으로 유도 |
| 서브쿼리 팩토링 | MATERIALIZE | WITH문으로 정의한 집합을 물리적으로 생성하도록 유도 |
|  | INLINE | WITH문으로 정의한 집합을 물리적으로 생성하지 않고 INLINE처리하도록 유도 |
| 쿼리변환 | MERGE | 뷰 머징 유도 |
|  | NO_MERGE | 뷰 머징 방지 |
|  | UNNEST | 서브쿼리 Unnesting 유도 |
|  | NO_UNNEST | 서브쿼리 Unnesting 방지 |
|  | PUSH_PRED | 조인조건 Pushdown 유도 |
|  | NO_PUSH_PRED | 조인조건 Pushdown 방지 |
|  | USE_CONCAT | OR 또는 IN-List 조건을 OR-Expansion으로 유도 |
|  | NO_EXPAND | OR 또는 IN-List 조건에 대한 OR-Expansion 방지 |
| 병렬 처리 | PARALLEL | 테이블 스캔 또는 DML을 병렬 방식으로 처리하도록 유도 |
|  | PARALLEL_INDEX | 인덱스 스캔으로 병렬방식으로 처리하도록 유도 |
|  | PQ_DISTRIBUTE | 병렬 수행 시 데이터 분배 방식 결정 |
| 기타 | APPEND | Direct-Path Insert로 유도 |
|  | DRIVING_SITE | DB Link Remote 쿼리에 대한 최적화 및 실행 주체 지정 |
|  | PUSH_SUBQ | 서브쿼리를 가급적 빨리 필터링하도록 유도 |
|  | NO_PUSH_SUBQ | 서브쿼리를 가급적 늦게 필터링하도록 유도 |

## 1.2 SQL 공유 및 재사용

### 소프트파싱 vs 하드파싱

- 라이브러리 캐시 : SQL 최적화 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간
- SGA(System Global Area) : 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간

![356798F1-63CD-4740-8503-D8CE0A70F852](https://user-images.githubusercontent.com/60471550/187572926-ab9dd35c-9b40-4839-ad3a-798f7b90d388.jpeg)

![15688380-1290-4BD5-999E-D4CC324FFF45](https://user-images.githubusercontent.com/60471550/187573043-c822db09-c41d-407b-8b4a-005fc0a45381.jpeg)


**SQL 실행 과정**

1. 사용자가 SQL문 전달
2. SQL 파싱
3. 해당 SQL이 라이브러리 캐시에 존재하는지 확인
    1. 존재할 경우 : 실행
    2. 존재하지 않을 경우 : 최적화하여 로우 소스 생성 후 실행
- 소프트파싱 : 라이브러리 캐시에 SQL이 존재하여 바로 실행단계로 넘어가는 것
- 하드파싱 : 라이브러리 캐시에 SQL이 존재하지 않아 최적화 및 로우 소스 생성 과정을 거친 후 실행하는 것

**SQL 최적화 과정이 하드한 이유**

- 최적의 실행 경로를 찾기 위해 고려해야할 요소가 매우 많음
    - 실행계획 후보군 도출
        - 조인 순서
        - 조인 방식
        - 액세스 방식
    - 효율성 판단
        - 테이블, 칼럼, 인덱스 구조에 관한 기본 정보
        - 오브젝트 통계
        - 시스템 통계
        - 옵티마이저 관련 파라미터
- 하드 파싱은 CPU를 많이 소비

### 바인드 변수의 중요성

**이름없는 SQL 문제**

- 사용자 정의 함수/프로시저, 트리거, 패키지 등
    - 생성할 때 이름을 가짐
    - 컴파일한 상태로 딕셔너리에 저장
    - 삭제하지 않으면 영구적으로 보관
    - 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용
- SQL
    - 이름이 없음, 전체 SQL 텍스트가 이름 역할
    - 딕셔너리에 저장하지 않음
    - 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용
    - 캐시 공간이 부족하면 버려져졌다가 다시 실행할 때 최적화 과정을 거쳐 캐시에 적재됨
- SQL은 그 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 다른 객체가 생성됨
- SQL은 개발 과정에서 수시로 변경이 일어나면 일회성이 많음
→ 모두 저장하려면 많은 공간이 필요하고, SQL을 찾는 속도가 느려짐
- 따라서 오라클, SQL Server 같은 DBMS는 SQL을 영구 저장하지 않음

**공유 가능 SQL**

- 바인드 변수 : 내부 처리 루틴이 같은 프로시저를 여러 개 생성하지 않고 하나로 공유하면서 재사용할 수 있도록 파라미터 Driven 방식으로 SQL을 작성할 때 사용하는 변수

## 1.3 데이터 저장 구조 및 I/O 매커니즘

### SQL이 느린 이유

- 디스크 I/O 때문
- I/O = SLEEP
    - OS 또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 SLEEP
- 프로세스 : 실행 중인 프로그램
- 프로세스 생명주기
    1. 생성(new)
    2. 반복
        1. 준비(ready)
        2. 실행(run)
        3. 대기(wait)
    3. 종료(terminate)
- 디스크에서 데이터를 읽어야 할 때 CPU를 OS에 반환하고 wait상태에서 I/O가 완료되기를 기다림
⇒ 느림

### 데이터베이스 저장 구조

![FA769AEE-A9D6-40FB-A4FC-5213804C40E8](https://user-images.githubusercontent.com/60471550/187573170-b256baac-8e3b-49a3-ab7f-de80c600fa57.jpeg)

- 테이블스페이스 : 세그먼트를 담는 컨테이너, 여러 개의 데이터파일로 구성
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트
    - 테이블
    - 인덱스
    - 파티션
    - LOB
- 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
- 데이터 블록 : 데이터를 읽고 쓰는 단위

![FACE6244-BFB6-4B39-A941-8476008B26F4](https://user-images.githubusercontent.com/60471550/187573213-9dcf8945-021b-4520-96b6-d023ef4310bf.jpeg)


- 세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받음
- 이 때 할당된 익스텐트는 다른 데이터파일에 위치 가능
- 인스텐트끼리는 연속된 공간이 아님
- 세그먼트에 할당된 익스텐트 목록 조회
    
    ```sql
    SELECT segment_type, tablespace_name, extent_id, file_id, block_id, blocks
    FROM dba_extents
    WHERE owner = USER
    AND segment_name = 'MY_SEGMENT'
    ORDER BY extent_id;
    ```
    
- DBA(Data Block Address)
    - 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지 나타내는 데이터 블록의 고유 주소값
    - 인덱스를 이용해 테이블 레코드를 읽을 때
        - 인덱스 ROWID(DBA + 로우 번호) 이용
    - 테이블 스캘할 때
        - 테이블 세그먼트 헤더에 저장된 익스텐트 맵 이용
        - 익스텐트 맵을 통해 익스텐트의 첫 번째 블록 DBA를 알 수 있음

### 블록단위 I/O

- 블록은 데이터를 읽고 쓰는 단위
- 기본적인 블록 사이즈 : 8KB
- 블록 사이즈 확인
  - `show parameter block_size` 
  - `select value from v$parameter where name = ‘db_block_size’;`

### 시퀀셜 액세스 vs 랜덤 액세스

- 시퀀셜 액세스 : 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
    - 인덱스
        - 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 연결돼 있음
        - 이 주소 값에 따라 앞뒤로 순차적으로 스캔
    - 테이블
        - 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리
        - 익스텐트 맵은 각 익스텐트의 첫 번째 블록 주소 값을 가짐
        - Full Table Scan : 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록 순서대로 읽는 스캔 방식
- 랜덤 액세스 : 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

### 논리적 I/O vs 물리적 I/O

**DB 버퍼캐시**

- 데이터 캐시
- 디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄임
- 데이터 블록을 읽을 땐 버퍼캐시부터 탐색
- 버퍼 캐시에 블록이 존재하면 I/O Call을 하지 않아도 됨
- 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 봄
- 버퍼 캐시 사이즈 확인 : `show sga`

**논리적 I/O vs 물리적 I/O**

- 논리적 블록 I/O : SQL을 처리하는 과정에 발생한 총 블록 I/O
- 논리적 I/O = 메모리 I/O + Direct Path I/O
- 물리적 블록 I/O : 디스크에서 발생한 총 블록 I/O
- 버퍼캐시에서 읽어야 할 블록을 찾지 못할 경우에만 디스크를 액세스하므로 논리적 블록 I/O 중 일부를 물리적을 I/O함
- 메모리 I/O는 전기적 신호 But 디스크 I/O는 액세스 Arm을 통해 물리적 작용이 일어나므로 매우 느림

![Untitled](https://user-images.githubusercontent.com/60471550/187573283-31179363-0f2d-4d74-88d4-dc46d8451b10.png)


**버퍼캐시 히트율**

- BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) × 100
           = ( (논리적 I/O - 물리적 I/O) / 논리적 I/O) × 100
           = ( 1 - (물리적 I/O) / (논리적 I/O) ) × 100
- 전체 블록 중 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율
- 물리적 I/O = 논리적 I/O × (100% - BCHR)
- SQL 튜닝 = 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것
- SQL 트레이스를 통해 수집한 Call 통계 정보
    
    ![Untitled 1](https://user-images.githubusercontent.com/60471550/187573334-60cae486-7912-42a8-9f17-725789946749.png)
    
    - 논리적 I/O = Query + Current = 1364044
    - 물리적 I/O = Disk = 601458
    - BCHR = (1 - (601458 / 1364044)) × 100 = 55.9%
- BCHR이 높다고 효율적인 SQL은 아님
    - 같은 블록을 비효율적으로 반복해서 읽어도 BCHR이 높아짐

### Single Block I/O vs Multiblock I/O

- Single Block I/O : 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
- Multiblock I/O : 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식
- 인덱스를 이용할 때는 Single Block I/O 사용
- 인덱스를 이용하지 않고 테이블 전체를 스캔할 때는 Multiblock I/O사용
- Multioblock I/O 방식으로 읽더라도 같은 익스텐트에 속한 블록만 읽음

### Table Full Scan vs Index Range Scan

- Table Full Scan : 테이블 전체를 스캔해서 읽는 방식
    - 테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는 방식
- Index Range Scan : 인덱스를 이용해서 읽는 방식
    - 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식
    - ROWID : 테이블 레코드가 디스크 상에 어디 저장됐는지를 가리키는 위치 정보
- Table Full Scan은 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽음
    - 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고, 캐시에서 못 찾으면 한 번의 수면을 통해 인접한 수십~수백개 블록을 한꺼번에 I/O하는 매커니즘
    - 많은 데이터를 읽을 때 유리
- Index Range Scan은 랜덤 액세스와 Single Block I/O 방식으로 디스크 블록 읽음
    - 레코드 하나를 읽기 위해 매번 잠을 자는 I/O 매커니즘
    - 큰 테이블에서 소량 데이터를 검색할 때 유리

### 캐시 탐색 매커니즘

- 버퍼 캐시 탐색 과정을 거치는 오퍼레이션
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
    - 테이블 블록을 Full Scan 할 때
- 버퍼 캐시에서 블록 찾는 과정
    1. 해시 알고리즘으로 버퍼 헤더 찾기
    2. 버퍼 헤더에서 얻은 포인터로 버퍼 블록 액세스
- 해시 구조 특징
    - 같은 입력 값은 항상  동일한 해시 체인(버킷)에 연결됨
    - 다른 입력 값이 동일한 해시 체인에 연결될 수 있음
    - 해시 체인 내에서는 정렬이 보장되지 않음

![Untitled 2](https://user-images.githubusercontent.com/60471550/187573411-cc00f064-d036-46c1-b287-5cadb8bf9b55.png)


**메모리 공유자원에 대한 액세스 직렬화**

- 버퍼 캐시는 SGA 구성요소이므로 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원
- 하나의 버퍼블록을 두 개 이상의 프로세스가 동시에 접근하려고 하면 블록 정합성에 문제가 생길 수 있음
- 한 프로세스씩 순차적으로 접근하도록 직렬화 매커니즘 필요
- 래치(Latch) : 직렬화가 가능하도록 지원하는 매커니즘
- 캐시버퍼 체인 래치 : 해시 체인을 스캔하는 동안 다른 프로세스가 체인 구조를 변경하면 안되므로 캐시버퍼 체인 래치를 획득한 프로세스만이 체인으로 진입할 수 있음
- 버퍼 Lock : 읽고자 하는 블록을 찾았으면 캐시버퍼 체인 래치를 해제해야는데, 버퍼 블록의 데이터 읽고 쓰는 과정 중에 후행 프로세스가 같은 블록에 접근하여 데이터를 읽고 쓴다면 데이터 정합성에 문제가 생길 수 있기 때문에 이를 방지하고자 존재하는 버퍼 블록 자체의 직렬화 매커니즘
- 직렬화 매커니즘에 의한 캐시 경합을 줄이려면 SQL튜닝을 통해 쿼리 일량 자체를 줄여야 함