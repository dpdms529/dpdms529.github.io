---
layout: single
title: "[솔크뿌] Solved.ac CLASS 뿌시기(10)"
excerpt: "CLASS 4 : p9251, p2206"
date: 2022-08-31T11:26:00+09:00
toc: true
toc_sticky: true
categories:
  - Algorithm
  - 솔크뿌
tags:
  - Algorithm
  - Java
  - 솔크뿌
---
## 9251번 - LCS

문제 링크 : <https://www.acmicpc.net/problem/9251>

![Untitled](https://user-images.githubusercontent.com/60471550/187578055-471718b0-3326-4332-a97e-f72af26741ad.png)

### 풀이

|  | 0 | A | C | A | Y | K | P |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| C | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
| A | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| P | 0 | 1 | 1 | 2 | 2 | 2 | 3 |
| C | 0 | 1 | 2 | 2 | 2 | 2 | 2 |
| A | 0 | 1 | 2 | 3 | 3 | 3 | 3 |
| K | 0 | 1 | 2 | 3 | 3 | 4 | 4 |
- 비교한 문자가 같을 경우
    - 대각선 왼쪽 위 값에 + 1을 한 값
    
      `dp[i][j] = dp[i-1][j-1] + 1`
- 비교한 문자가 다를 경우
    - 위쪽 값과 왼쪽 값 중 큰 값
    
       `dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]`
        

### 코드

```java
package p9251;

import java.util.*;
import java.io.*;

public class Main {
    static String str1, str2;
    static int[][] dp = new int[1001][1001];

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        str1 = br.readLine();
        str2 = br.readLine();

        lcs();

        System.out.println(dp[str1.length()][str2.length()]);
    }

    static void lcs(){
        for(int i = 1;i<=str1.length();i++){
            for(int j = 1;j<=str2.length();j++){
                if(str1.charAt(i-1) == str2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
    }
}
```

## 2206번 - 벽 부수고 이동하기

문제 링크 : <https://www.acmicpc.net/problem/2206>

![Untitled](https://user-images.githubusercontent.com/60471550/187578431-878d7e90-df3f-4ac5-ace4-855bbf24b547.png)

### 풀이

- 벽을 하나씩 부셔보면서 bfs를 돌리면 시간초과 발생
- visited 배열을 3차원으로 생성하여 벽을 부순 여부를 체크
    - 다음 위치에 벽이 존재하는 경우
        - 현재까지 벽을 부순 적이 없고, 다음 위치를 벽을 부수고 방문한 적이 없다면 방문 처리 후 큐에 삽입
    - 다음 위치에 벽이 존재하지 않는 경우
        - 다음 위치를 방문한 적이 없다면 방문 처리 후 큐에 삽입
- 현재 위치가 도착 위치에 처음으로 도달하게 되면 최단 경로이므로 루프를 멈추고 결과 출력

### 코드

```java
package p2206;

import java.util.*;
import java.io.*;

public class Main {
    static int N,M;
    static int[][] graph;
    static int[][] distance;
    static boolean[][][] visited;
    static int[] dy = {-1,1,0,0};
    static int[] dx = {0,0,-1,1};

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        graph = new int[N][M];
        distance = new int[N][M];
        visited = new boolean[2][N][M];

        for(int i = 0;i<N;i++){
            String tmp = br.readLine();
            for(int j = 0;j<M;j++){
                graph[i][j] = tmp.charAt(j) - '0';
            }
        }

        bfs(0,0);
    }

    static void bfs(int y, int x){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0,y,x});
        visited[0][y][x] = true;
        distance[y][x] = 1;
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            int isBroken = cur[0];
            int cy = cur[1];
            int cx = cur[2];
            if(cy == N-1 && cx == M-1){
                System.out.println(distance[cy][cx]);
                return;
            }
            for(int i = 0;i<4;i++){
                int ny = cy + dy[i];
                int nx = cx + dx[i];
                if(ny>=0 && ny<N && nx>=0 && nx<M){
                    if(graph[ny][nx] == 1){
                        if(isBroken==0 && !visited[1][ny][nx]){
                            visited[1][ny][nx] = true;
                            distance[ny][nx] = distance[cy][cx] + 1;
                            queue.offer(new int[]{1,ny,nx});
                        }
                    }else{
                        if(!visited[isBroken][ny][nx]){
                            visited[isBroken][ny][nx] = true;
                            distance[ny][nx] = distance[cy][cx] + 1;
                            queue.offer(new int[]{isBroken,ny,nx});
                        }
                    }
                }
            }
        }
        System.out.println(-1);;
    }
}
```