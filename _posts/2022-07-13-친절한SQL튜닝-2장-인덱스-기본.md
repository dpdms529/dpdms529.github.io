---
layout: single
title: "[친절한SQL튜닝] 2장 인덱스 기본"
excerpt: "2장 인덱스 기본"
date: 2022-07-13T02:08:00+09:00
toc: true
toc_sticky: true
categories:
  - DB 
  - 친절한SQL튜닝
tags:
  - DB
  - SQL
  - 친절한SQL튜닝
---

## 2.1 인덱스 구조 및 탐색

### 미리 보는 인덱스 튜닝

**데이터를 찾는 두 가지 방법**

- 테이블 전체 스캔
- 인덱스 이용

**인덱스 튜닝의 두 가지 핵심 요소**

- 인덱스 스캔 효율화 튜닝
- 랜덤 액세스 최소화 튜닝

**SQL튜닝은 랜덤 I/O와의 전쟁**

- 데이터베이스 성능이 느린 이유
    - 디스크 I/O
    - 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중 랜덤 I/O가 특히 중요

### 인덱스 구조

- 인덱스 : 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트
- 인덱스는 정렬되어 있기 때문에 범위 스캔이 가능
- 일반적으로  B*Tree 인덱스 사용
- 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 가짐
- 키 값은 하위 블록에 저장된 키값의 범위
- LMC(Leftmost Child) : 가장 왼쪽 첫 번째 레코드
    - 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킴
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬되어 있으며, 테이블 레코드를 가리키는 주소값인 ROWID를 가짐
- 인덱스 키값이 같으면 ROWID 순으로 정렬됨
- ROWID = 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정
    - 수직적 탐색 : 인덱스 스캔 시작 지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 인덱스 수직적 탐색

- 인덱스 스캔 시작 지점을 찾는 과정
- 루트 블록에서부터 시작해서 하위 블록의 주소값을 찾아 수직적 탐색
- 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가리키는 하위 블록으로 이동

### 인덱스 수평적 탐색

- 데이터를 찾는 과정
- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 가짐 - 양방향 연결 리스트 구조
- 인덱스를 수평적으로 탐색하는 이유
    - 조건절을 만족하는 데이터를 모두 찾기 위해
    - ROWID를 얻기 위해

### 결합 인덱스 구조와 탐색

- 인덱스 선두 컬럼을 모두 = 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능이 같음

**Balanced의 의미**

- B*Tree의 B는 Balanced
- 어떤 값으로 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록 수가 같음
- 루트로부터 모드 리프 블록까지의 높이가 항상 같음

## 2.2 인덱스 기본 사용법

### 인덱스를 사용한다는 것

- 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용 가능
- 인덱스 컬럼을 가공해도 인덱스를 사용 가능하지만 Index Full Scan 방식으로 작동함

### 인덱스를 Range Scan 할 수 없는 이유

- 인덱스 컬럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문에 Index Range Scan이 불가능
- Index Range Scan을 하려면 시작지점과 끝지점이 있어야 함
- LIKE로 중간 값을 검색할 때도 Index Range Scan 불가능
    - `where 업체명 like ‘%대한%’`
- OR 조건으로 검색할 때도 Index Range Scan 불가능
    - IN 조건도 OR 조건의 다른 표현 방식이므로 Index Range Scan 불가능
- UNION ALL 방식을 사용하면 Index Range Scan 가능
- OR Expansion
    - OR 조건식을 사용한 쿼리를 SQL 옵티마이저가 UNION ALL 을 사용한 쿼리로 변환하여 인덱스를 사용할 수 있도록 할 수 있음
    - 이것을 OR Expansion이라고 함
    - use_concat 힌트를 사용하면 OR Expansion을 유도할 수 있음
- IN-List Iterator
    - IN 조건절에 대해 SQL 옵티마이저가 IN-List Iterator 방식을 사용
    - IN-List 개수만큼 Index Range Scan을 반복하여 UNION ALL방식으로 변환한 것과 같은 효과를 얻음

### 더 중요한 인덱스 사용 조건

- Index Range Scan을 하기 위해 가장 중요한 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 것
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 Index Range Scan은 무조건 가능

**인덱스 잘 타니까 튜닝 끝?**

- 인덱스를 탄다 = Index Range Scan을 한다.
- Index Range Scan을 한다고 무조건 효율적이지 않음
- 인덱스 리프 블록에서 스캔하는 양을 따져봐야 인덱스를 잘 타는지 알 수 있음

### 인덱스를 이용한 소트 연산 생략

- 인덱스는 정렬되어 있기 때문에 소트 연산을 생략할 수 있음

### ORDER BY 절에서 컬럼 가공

- ORDER BY 절에서 컬럼을 가공하면 가공한 값 기준으로 정렬을 해야하므로 인덱스를 사용할 수 없음 → 정렬 연산 생략 불가능

### SELECT-LIST에서 컬럼 가공*

- MIN/MAX 함수를 사용하면 인덱스 리프 블록의 왼쪽/오른쪽에서 레코드 하나만 읽고 멈출 수 있음 → 정렬 연산 생략 가능
- MIN/MAX를 사용하기 전 컬럼을 가공하면 인덱스 사용 불가능하므로 정렬 연산 생략 불가능

### 자동 형변환

- 오라클은 조건절 양쪽 값의 데이터 타입이 서로 다르면 자동 형변환 후 비교
- 숫자형과 문자형이 만나면 문자형을 숫자형으로 변환
- 날짜형과 문자형이 만나면 문자형을 날짜형으로 변환
- 날짜 포맷을 정확히 지정해주는 것이 필요
    - TO_DATE(’01-JAN-2018’, ‘DD-MON-YYYY’)
- LIKE 연산자를 사용하면 숫자형이 문자형으로 변환됨

**자동 형변환 주의**

- decode(a,b,c,d)를 처리할 때 a=b이면 c를 반환하고 아니면 d 반환
- 이 때 반환값의 데이터 타입은 c에 의해 결정됨
- c가 null이면 varchar2로 취급함
- 숫자형을 반환해야하는 경우 c가 null이면 d가 문자형으로 바뀌어 문자열 기준으로 값을 출력하는 오류 발생 가능
- c에 null을 써야하는 경우 TO_NUMBER(null) 또는 0 사용

## 2.3 인덱스 확장기능 사용법

### Index Range Scan

- 인덱스 루트에서 리프 블록까지 수직적으로 탐색 후 필요한 범위만 스캔
- 선두 컬럼을 가공하지 않은 상태로 조건절에 사용하면 Index Range Scan 가능
- 성능은 인덱스 스캔 범위, 테이블 액세스 횟수에 따라 결정됨

### Index Full Scan

- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식

Index Full Scan의 효용성

- Index Range Scan이 불가능하고 테이블의 아주 일부만 액세스하는 상황이면 Index Full Scan 사용

**인덱스를 이용한 소트 연산 생략**

- first_rows 힌트로 처음 일부를 출력할 경우 Index Full Scan으로 성능 개선 효과를 얻을 수 있음
- But 데이터를 끝까지 읽는다면 Table Full Scan보다 훨신 더 많은 I/O를 발생시켜 성능이 나빠질 수 있음

### Index Unique Scan

- 수직적 탐색만으로 데이터를 찾는 스캔 방식
- Unique 인덱스를 = 조건으로 탐색하는 경우 작동
    - Unique 인덱스가 존재하는 컬럼은 중복 값이 없으므로 = 조건으로 검색할 때 데이터를 한 건 찾는 순간 탐색할 필요가 없음
- Unique 인덱스를 범위 검색 조건(between, 부등호, like)으로 검색할 때는 Index Range Scan
- Unique 결합 인덱스에 대해 일부 컬럼만으로 검색할 때도 Index Range Scan

### Index Skip Scan

- 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용
- 관련 힌트 : index_ss, no_index_ss
- 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스하는 스캔 방식

**Index Skip Scan이 작동하기 위한 조건**

### Index Fast Full Scan

- Index Full Scan보다 빠름
- 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문
- 관련 힌트 : index_ffs, no_index_ffs
- 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 효과적
- 인덱스 키 순서대로 정렬되지 않음
- 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때만 사용 가능
- 인덱스가 파티션 돼 있지 않더라도 병렬 쿼리가 가능

### Index Range Scan Descending

- Index Range Scan과 동일하지만 내림차순으로 정렬된 결과 집합을 얻음
- 힌트 : index_desc
- MAX 값 구할 때